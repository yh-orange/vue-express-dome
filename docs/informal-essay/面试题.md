## HTTP

### GET和POST的请求的区别
**Post 和 Get 是 HTTP 请求的两种方法，其区别如下：**
* **「应用场景：」** (GET 请求是一个**「幂等」**的请求)一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。(而 Post 不是一个**「幂等」**的请求)一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。（**「幂等是指一个请求方法执行多次和仅执行一次的效果完全相同」**）
* **「是否缓存：」** 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
* **「传参方式不同：」** Get 通过查询字符串传参，Post 通过请求体传参。
* **「安全性：」** Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
* **「请求长度：」** 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
* **「参数类型：」** get参数只允许ASCII字符，post 的参数传递支持更多的数据类型(如文件、图片)。

### POST和PUT请求的区别
PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时**「更新数据」**）
POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是**「创建数据」**）

**为什么post请求会发送两次请求?**
1. 第一次请求为options预检请求，状态码为:204
    * 作用1: 询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求
    * 作用2: 检测服务器是否为同源请求,是否支持跨域
2. 第二次为真正的post请求

### 常见的HTTP请求头和响应头
**HTTP Request Header**

* Accept:浏览器能够处理的内容类型
* Accept-Charset:浏览器能够显示的字符集
* Accept-Encoding：浏览器能够处理的压缩编码
* Accept-Language：浏览器当前设置的语言
* Connection：浏览器与服务器之间连接的类型
* Cookie：当前页面设置的任何Cookie
* Host：发出请求的页面所在的域
* Referer：发出请求的页面的URL
* User-Agent：浏览器的用户代理字符串

**HTTP Responses Header**

* Date：表示消息发送的时间，时间的描述格式由rfc822定义
* server:服务器名称
* Connection：浏览器与服务器之间连接的类型
* Cache-Control：控制HTTP缓存
* content-type:表示后面的文档属于什么MIME类型

**Content-Type**
**「常见的 Content-Type 属性值有以下四种：」**

* `application/x-www-form-urlencoded`：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。
* `multipart/form-data`：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。
* `application/json`：服务器消息主体是序列化后的 JSON 字符串。
* `text/xml`：该种方式主要用来提交 XML 格式的数据。

### HTTP状态码304是多好还是少好
**「为什么会有304」**
服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。

状态码304不应该认为是一种错误，而是对客户端**「有缓存情况下」**服务端的一种响应。

搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。

**「产生较多304状态码的原因：」**

* 页面更新周期长或不更新
* 纯静态页面或强制生成静态html

**「304状态码出现过多会造成以下问题：」**

* 网站快照停止；
* 收录减少；
* 权重下降。

### 常见的HTTP请求方法
* `GET`: 向服务器获取数据；
* `POST`：发送数据给服务器，通常会造成服务器资源的新增修改；
* `PUT`：用于全量修改目标资源(看接口，也可以用于添加)；
* `PATCH`：用于对资源进行部分修改
* `DELETE`：用于删除指定的资源；
* `HEAD`：获取报文首部，与GET相比，不返回报文主体部分；使用场景是比如下载一个大文件前，先获取其大小再决定是否要下载，以此可以节约宽带资源
* `OPTIONS`：(浏览器自动执行)、询问支持的请求方法，用来跨域请求、预检请求、判断目标是否安全；
* `CONNECT`：要求在与代理服务器通信时建立「管道」，使用「管道」进行TCP通信；(把服务器作为跳板，让服务器代替用户去访问其他网页，之后把数据原原本本的返回给用户)
* `TRACE`: 该方法会让服务器原样返回任意客户端请求的信息内容，主要⽤于测试或诊断。

### 说说Ajax组成部分

Ajax(阿贾克斯)：全称 Asynchronous Javascript And XML(异步的js与xml)

* 说人话：「用js发送异步的网络请求」

* A : Asynchronous 异步

* J：Javascript

* A ：And

* X : XML 与 XMLHttpRequest
    * 在JSON没有出来以前, 网络传输主要以XML格式数据为主。后来JSON问世，逐渐取代XML。但是由于ajax技术出来的比json早，因此xml这个称呼一直保留至今

* XML ：解决跨平台数据传输。

### 请介绍一下XMLHTTPRequest对象

**「Ajax的核心是XMLHTTPRequest」**。它是一种支持异步请求的技术。XMLHTTPRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。可以在页面加载以后进行页面的局部更新

**使用方法**
1. 实例化ajax对象
2. open()：创建HTTP请求 第一个参数是指定提交方式(post、get) 第二个参数是指定要提交的地址是哪 第三个参数是指定是异步还是同步(true表示异步，false表示同步) 第四和第五参数在HTTP认证的时候会用到。是可选的
3. 设置请求头：「setRequestHeader」(Stringheader,Stringvalue) 「（使用post方式才会使用到，get方法并不需要调用该方法）」
4. 发送请求：「send(content)」 ：发送请求给服务器 如果是get方式，并不需要填写参数，或填写null 如果是post方式，把要提交的参数写上去
5. 注册回调函数
```js
 /* 1.ajax： 在页面不刷新的情况下向服务器请求数据
           2.XMLHttpRequest ：http请求对象，负责实现ajax技术（小黄人）
                （1）创建XMLHttpRequest对象
                        * 小黄人，相当于黄袍加身的跑腿外卖小哥哥
                （2）设置请求
                        * 告诉小黄人服务器地址
                （3）发送请求
                        * 小黄人出发去指定地址取外卖（数据）
                            * 2G网速：走路去的
                            * 3G网速：骑膜拜去的
                            * WIFI : 骑电动车去的
                            * 4G   ： 骑小牛牌电动车去的
                （4）注册回调函数
                        * 小黄人把取回的外卖送到你家门口
        
         */
//(1).实例化ajax对象
      let xhr = new XMLHttpRequest();
      //(2).设置请求方法和地址;
      xhr.open("post", "http://www.liulongbin.top:3009/api/login");
      //(3).设置请求头（post请求才需要设置）;
      xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      //(4).发送请求 ： 参数格式  'key=value';
      xhr.send("username=admin&password=123456");
      //(5).注册回调函数
      // xhr.onload = function() {};
      xhr.onreadystatechange = function() {
        //onreadystatechange会触发多次，一般需要判断xhr.readState == 4 才获取响应数据
        if (xhr.readyState === 4) {
          console.log(xhr.responseText)
        }
      }
```

**onreadstatechange事件**

```js
/** 1. onload事件 ：  接收服务器响应的数（一次请求，只会执行一次）
  * 2. onreadystatechang事件 : 作用与onload事件一致（一次请求，会执行多次）
  *    面试点：XMLHttpRequest对象的状态码 （xhr.readyState）
  * 0  请求未建立  (创建了xhr对象，但是还没调用open)
  * 1  服务器连接已建立 
  * 2. 请求已接收  (send之后,服务器已经接收了请求)
  * 3. 请求处理中 
  * 4. 请求已完成，且响应已就绪 （ 4状态码等同于onload事件 ）
**/
        
      //(1).实例化ajax对象
             let xhr = new XMLHttpRequest()
             console.log(xhr.readyState) //0
             //(2).设置请求方法和地址
             xhr.open("post", "http://www.liulongbin.top:3009/api/login")
               console.log(xhr.readyState) //1
             //(3).设置请求头（post请求才需要设置）
             xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
             console.log(xhr.readyState) //1
             //(4).发送请求 ： 参数格式  'key=value'
             xhr.send("username=admin&password=123456")
               console.log(xhr.readyState) //1
             //(5).注册回调函数
             //a. onload 是新式浏览器才支持的
             //b. 如果要兼容更早的浏览器，可以使用 onreadystatechange
             //c. onreadystatechange触发时机 ：xhr.readState状态变化
             // xhr.onload = function() {};
       
             xhr.onreadystatechange = function() {
               console.log(xhr.readyState) //2,3,4
               //onreadystatechange会触发多次，一般需要判断xhr.readState == 4 才获取响应数据
               if (xhr.readyState == 4) {
                 console.log(xhr.responseText)
               }
             }
```

**如何上传文件（上传图片）**
```js
   /**文件上传思路总结 
      1. 给file表单注册onchange事件 
        * 当用户选择图片之后执行
      2. 获取用户选择的图片 
        * this.files[0]
      3. 创建FormData对象 
        * 只有FormData才可以上传文件
      4. 将图片添加到FormData对象中 
        * fd.append('参数名', this.files[0])
      5. 发送ajax请求
        * 文件上传请求方法一定是post, 且请求参数为 FormData对象
      **/
     
      //1. file类型表单自带一个选择文件点击按钮，当用户选择文件之后就会触发onchange事件
      document.querySelector("#iptFile").onchange = function() {
        //this : file表单
        //(1)获取用户选择的文件
        let file = this.files[0]
        // 非空判断，如果内容为undefined，给出提示
        if (file == undefined) {
          return alert("请选择上传文件！")
        }
        //(2)创建FormData对象， 只有FormData对象才可以上传文件
        let fd = new FormData()
        //(3)添加文件
        fd.append("avatar", file)
        //(4)发送ajax请求, 参数为 FormData对象
        axios({
          method: "POST",
          url: "http://www.liulongbin.top:3009/api/upload/avatar",
          data: fd
        }).then(({ data: res }) => {
          console.log(res)
          if (res.code != 200) {
            return alert(res.message)
          }
          // 成功后提示，修改图片路径
          alert("恭喜您，上传头像成功！")
          document.querySelector("img").src = `http://www.liulongbin.top:3009${res.url}`
        })
      }
```

**如何自定义上传文件按钮**
```js
//自定义文件上传按钮思路
//(1)隐藏file表单
//(2)给自定义按钮添加一个点击事件
//(3)点击按钮的时候，触发 file表单的点击 

document.querySelector('#btnChoose').onclick = function(){

//dom对象.onclick()  :  只能触发你自己注册的onclick事件，没注册触发不了
//dom对象.click() : 模拟鼠标点击。 触发注册的onclick事件 + 默认点击事件
  
document.querySelector('#iptFile').click()
    
}
```

**ajax请求如何取消**
1. 原生xhr取消请求
```js
var xhr = new XMLHttpRequest();
xhr.abort();
```

2. axios取消请求
    1. 使用 `CancelToken.source` 工厂方法创建 `cancel token`
    
```js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();
axios.get('/user/123', {
    cancelToken: source.token
}).catch(function(thrown) {
    if (axios.isCancel(thrown)) {
        console.log('Request canceled', thrown.message);
    } else {
    // 处理错误
    }
});

axios.post('/user/123', {
    name: '小明'
}, {
    cancelToken: source.token
});

// 取消请求（message 参数是可选的）
source.cancel('canceled by the user.');
```

    2. 传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token
```js
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  })
});

// cancel the request
cancel();
```

**取消ajax请求有什么意义**
1. 已发出的请求可能仍然会到达后端
2. 取消后续的回调处理，避免多余的回调处理，以及特殊情况，先发出的后返回，导致回调中的数据错误覆盖
3. 取消loading效果，以及该请求的其他交互效果，特别是在单页应用中，A页面跳转到B页面之后，A页面的请求应该取消，否则回调中的一些处理可能影响B页面
4. 超时处理，错误处理等都省去了，节约资源

### OPTIONS请求方法及使用场景

OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。(浏览器自动执行)

OPTIONS方法是用于请求获得由`Request-URI`标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以 **「在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能」**。该请求方法的响应不能缓存。

OPTIONS请求方法的 **「主要用途」** 有两个：
* 获取服务器支持的所有HTTP请求方法；
* 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送 **「嗅探」** 请求，以判断是否有对指定资源的访问权限。

### HTTP 1.0 和 HTTP 1.1 之间有哪些区别？

**「连接方面」**: http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
**「资源请求方面」**: 在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
**「缓存方面」**: 在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
**「http1.1」**:  中「新增了 host 字段」，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
http1.1 相对于 http1.0 还新增了很多「请求方法」，如 PUT、HEAD、OPTIONS 等。

### HTTP 1.1 和 HTTP 2.0 的区别

* 「二进制协议」：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。
* 「多路复用：」 HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"【1】的问题。
* 「数据流：」 HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
* 「头信息压缩：」 HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
* 「服务器推送：」 HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

### 什么是队头堵塞
队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。

### 队头阻塞的解决方案
**并发连接**：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。
**域名分片**：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。

### HTTP和HTTPS协议的区别
HTTP和HTTPS协议的主要区别如下：

* HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
* HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
* 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；
* HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。

### GET方法URL长度限制的原因
实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的「浏览器」及「服务器」对它的限制。IE对URL长度的限制是「2083」字节(2K+35)。由于IE浏览器对URL长度的允许值是「最小的」，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。

`GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）`
下面看一下主流浏览器对get方法中url的长度限制范围：
* Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为「2083」个字符，如果超过这个数字，提交按钮没有任何反应。
* Firefox (Browser)：对于Firefox浏览器URL的长度限制为 「65,536」 个字符。
* Safari (Browser)：URL最大长度限制为 「80,000」 个字符。
* Opera (Browser)：URL最大长度限制为 「190,000」 个字符。
* Google (chrome)：URL最大长度限制为 「8182」 个字符。
主流的服务器对get方法中url的长度限制范围：
* Apache (Server)：能接受最大url长度为「8192」个字符。
* Microsoft Internet Information Server(IIS)：能接受最大url的长度为「16384」个字符。

根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。

### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
（1）「解析URL：」 「首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径」。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）「缓存判断：」 「浏览器会判断所请求的资源是否在缓存里」，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）「DNS解析：」 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会「判断本地是否有该域名的 IP 地址的缓存」，如果有则使用，「如果没有则向本地 DNS 服务器发起请求」。「本地 DNS 服务器也会先检查是否存在缓存」，如果「没有就会先向根域名服务器发起请求」，获得负责的顶级域名服务器的地址后，「再向顶级域名服务器请求」，然后获得负责的权威域名服务器的地址后，「再向权威域名服务器发起请求」，「最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户」。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）「获取MAC地址（选说）」 当浏览器得到 IP 地址后，「数据传输还需要知道目的主机 MAC 地址」，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

（5）「TCP三次握手：」 ，「确认客户端与服务器的接收与发送能力」，下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
>1、客户端主机C说：“我可以给你发送数据吗？”
>2、服务器S说：“可以的，不过我可能也会给你发送数据。”
>3、C：“好，那我开始互相发送数据吧。”

（6）「HTTPS握手（选说）：」 「如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程」。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）「发送HTTP请求」

「服务器处理请求,返回HTTP报文」(响应)(文件)

（8）「页面渲染：」 浏览器首先会根据 html 文件(响应) 「建 DOM 树」，根据解析到的 css 文件构「建 CSSOM 树」，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。「当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树」。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

（9）「TCP四次挥手：」 「最后一步是 TCP 断开连接的四次挥手过程」。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。
>四次挥手的情景大致是这样的：
>1、客户端主机C说：“我没有数据了，断开连接吧。 ”
>2、服务器S说：“好，但是我还有数据（不断给C发送数据，此时C已经不能给S发送数据了，但是必须要就收S发来的数据）。”
>3、（当S给C发完数据后）S说：“我发完了，断开连接吧。”
>4、C说：“好，断开连接吧。

### 页面有多张图片，HTTP是怎样的加载表现？
在`HTTP 1`下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用「多域名部署」解决。这样可以提高同时请求的数目，加快页面图片的获取速度。

在`HTTP 2`下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。

### HTTP2的头部压缩算法是怎样的？
HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。

具体来说:
* 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；
* 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；
* 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。

### HTTP请求报文的是什么样的？
请求报⽂有4部分组成:
* 请求⾏
* 请求头部
* 空⾏
* 请求体

**「其中：」**
（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。

（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔

* User-Agent：产⽣请求的浏览器类型。
* Accept：客户端可识别的内容类型列表。
* Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。

（3）请求体: post put等请求携带的数据

### HTTP响应报文的是什么样的？
请求报⽂有4部分组成:

* 响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK
* 响应头：响应部⾸组成
* 空⾏
* 响应体：服务器响应的数据

### HTTP协议的优点和缺点
HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。

HTTP协议具有以下「优点」：
* 支持客户端/服务器模式
* **「简单快速」**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
* **「无连接」**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
* **「无状态」**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
* **「灵活」**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

HTTP协议具有以下「缺点」：

* **「无状态：」** HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
* **「明文传输：」** 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
* **「不安全」**
    * 通信使用明文（不加密），内容可能会被窃听；
    * 不验证通信方的身份，因此有可能遭遇伪装；
    * 无法证明报文的完整性，所以有可能已遭篡改；

### 说一下HTTP 3.0
HTTP3.0，也称作HTTP over QUIC。HTTP3.0的核心是QUIC(读音quick)协议，由Google在 2015年提出的SPDY v3演化而来的新协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议，可以定义成:**HTTP3.0基于UDP的安全可靠的HTTP2.0协议**。

###  HTTP的两种连接模式
HTTP 协议是基于 TCP/IP，并且使用了「请求-应答」的通信模式。

**「HTTP协议有两种连接模式，一种是持续连接，一种非持续连接」**。
1. 非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。
2. 持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。

### URL有哪些组成部分
以下面的URL为例www.aspxfans.com:8080/news/index?ID=246188#name

从上面的URL可以看出，一个完整的URL包括以下几部分：
* **「协议部分」**：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符；
* **「域名部分」**：该URL的域名部分为www.aspxfans.com。一个URL中，也可以使用IP地址作为域名使用
* **「端口部分」**：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；
* **「虚拟目录部分」**：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；
* **「文件名部分」**：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；
* **「锚部分」**：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；
* **「参数部分」**：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

### 与缓存相关的HTTP请求头有哪些
强缓存：
* Expires
* Cache-Control

协商缓存：
* Etag、If-None-Match
* Last-Modified、If-Modified-Since

###  强缓存和协商缓存

**「强缓存：」** 不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache两种（灰色表示缓存）。

**「协商缓存：」** 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

>共同点：都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。

### HTTP的keep-alive有什么作用？

**http1.0默认关闭，需要手动开启。http1.1后默认开启**

**「作用：」** 使客户端到服务器端的链接持续有效(「长连接」)，当出现对服务器的后续请求时，keep-Alive功能避免了建立或者重新建立链接。

**「使用方法：」** 在请求头中加上Connection：keep-alive。

**「优点：」**
* 较少的CPU和内存的占用(因为要打开的连接数变少了，复用了连接)
* 减少了后续请求的延迟(无需再进行握手)

**「缺点：」** 本来可以释放的资源仍旧被占用。有的请求已经结束了，但是还一直连接着。

**「解决方法：」** 服务器设置过期时间和请求次数，超过这个时间或者次数就断掉连接。

### OSI的七层模型是什么？
OSI于1978年开发的一套标准架构ISO模型，被引用来说明数据通信协议的结构和功能。

OSI在功能上可以划分为两组：

网络群组：物理层、数据链路层、网络层

使用者群组：传输层、会话层、表示层、应用层

| - | - | - |
|**OSI七层网络模型** | **TCP/IP四层概念模型** | **对应网络协议** |
|7：应用层 | 应用层	| HTTP、RTSP TFTP（简单文本传输协议）、FTP、 NFS（数域筛法，数据加密）、WAIS`（广域信息查询系统）|
|6：表示层 | 应用层	| Telnet（internet远程登陆服务的标准协议）、Rlogin、SNMP（网络管理协议）、Gopher|
|5：会话层 | 应用层	| SMTP（简单邮件传输协议）、DNS（域名系统）|
|4：传输层 | 传输层	| TCP（传输控制协议）、UDP（用户数据报协议））|
|3：网络层 | 网际层	| ARP（地域解析协议）、RARP、AKP、UUCP（Unix to Unix copy）|
|2：数据链路层 |	数据链路层	FDDI（光纤分布式数据接口）、Ethernet、Arpanet、PDN（公用数据网）、SLIP（串行线路网际协议）PPP（点对点协议，通过拨号或专线方建立点对点连接发送数据）|
|1：物理层 | 物理层	| SMTP（简单邮件传输协议）、DNS（域名系统）|
























[原文地址](https://mp.weixin.qq.com/s?__biz=MzUzNTk3MjE2Ng==&mid=2247501486&idx=1&sn=c0908d633ccd4b071a16d14c147dafbf&chksm=faffd687cd885f91290e753aa9468720d4d3b9f0d3d055dd8b6a426997172de50127cb02da60&scene=126&&sessionid=1665275992#rd)

## HTTPS

1. 什么是HTTPS协议？
**超文本传输安全协议**（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。**「HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。」** HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

![HTTPS协议](/images/informal-essay6.png)

HTTP协议采用 **「明文传输」** 信息，存在 **「信息窃听」**、**「信息篡改」** 和 **「信息劫持」** 的风险，而协议TLS/SSL具有「身份验证」、「信息加密」和「完整性校验」的功能，可以避免此类问题发生。

安全层的主要职责就是 **「对发起的HTTP请求的数据进行加密操作」** 和 **「对接收到的HTTP的内容进行解密操作」**。

2. TLS/SSL的工作原理
「TLS」全称「安全传输层协议」（Transport Layer Security）及其前身「安全套接层」（Secure Sockets Layer，缩写作「SSL」） 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。

TLS/SSL的功能实现主要依赖三类基本算法：「散列函数hash」、「对称加密」、「非对称加密」。这三类算法的作用如下：
* 散列算法用来验证信息的完整性
* 对称加密算法采用协商的秘钥对数据加密
* 非对称加密实现身份认证和秘钥协商

![HTTPS协议](/images/informal-essay7.png)

### 对称加密、非对称加密是什么，有什么区别？
**「对称加密和非对称加密是安全传输层里的加密算法」**

**「对称加密」**
对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，

这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难

**「通信的双⽅都使⽤同⼀个秘钥进⾏加密, 解密。」** ⽐如，两个人事先约定的暗号，就属于对称加密。

![HTTPS协议](/images/informal-essay8.png)

**「优点:」**

计算量小、加密速度快、加密效率高。

**「缺点:」**

「在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。」

「如果一方的秘钥被泄露，那么加密信息也就不安全了」

最不安全的地方, 就在于第一开始, 互相约定密钥的时候!!! 传递密钥!

使用场景：本地数据加密、https 通信、网络传输等

***

**「非对称加密」**
通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。

特征: 私钥可以解密公钥加密的内容, 公钥可以解密私钥加密的内容

![HTTPS协议](/images/informal-essay9.png)

非对称加密的特点是：
* 优点：非对称加密与对称加密相比其安全性更好
* **「缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。」**

使用场景：https 会话前期、CA 数字证书、信息加密、登录认证等

### 数字证书是什么？
使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为「数字证书」。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。

4.2 数字证书的作用
现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用「数字证书」。

4.3 数字签名是什么？
数字签名就是先用CA自带的Hash算法来计算出证书内容的一个摘要，然后使用CA私钥进行加密，组成数字签名。

当别人把他的数字证书发过来时，接收方用同样的算法再次生成摘要，用CA公钥解密后得到CA生成的摘要，两者进行对比后，就能确定中间是否被人篡改。这样就能最大程度的保证通信的安全了。

### HTTPS通信（握手）过程

HTTPS的通信过程如下：

1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。

### HTTPS的优缺点
HTTPS的`「优点」`如下：
* 使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；
* 使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；
* HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；

HTTPS的`「缺点」`如下：
* HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；
* HTTPS协议握手阶段比较费时，增加页面的加载时间；
* SSL证书是收费的，功能越强大的证书费用越高；
* HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；
* SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。

### HTTPS是如何保证安全的
结合「对称加密」和「非对称加密」两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。

这个时候还需要⼀个安全的「第三⽅颁发证书」（CA），证明身份的身份，防⽌被中间⼈攻击。

为了防止中间人篡改证书，需要用到「数字签名」这个技术

>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了

### HTTP状态码分别代表什么意思？

| - | - | - |
|「类别」 | 「原因」 | 「描述」|
| 1xx |Informational(信息性状态码) | 接受的请求正在处理|
| 2xx |Success(成功状态码) | 请求正常处理完毕|
| 3xx |Redirection(重定向状态码) | 需要进行附加操作一完成请求|
| 4xx |Client Error (客户端错误状态码) | 服务器无法处理请求|
| 5xx |Server Error(服务器错误状态码) | 服务器处理请求出错|

**「（1）2XX 成功」**
* 200 OK，表示从客户端发来的请求在服务器端被正确处理
* 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。通常是在POST请求，或者是某些PUT请求之后创建了内容，进行的返回的响应。
* 202 Accepted 请求服务器已接受，但是尚未处理，不保证完成请求。适合异步任务或者说需要处理时间比较长的请求，避免HTTP链接一直占用。
* 204 No content，表示请求成功，但响应报文不含实体的主体部分
* 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
* 206 Partial Content，进行的是范围请求，表示服务器已经成功处理了部分GET请求，响应头中会包含获取的内容范围(常用于分段下载)
***

**「（2）3XX 重定向」**
* 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
* 302 found，临时性重定向，表示资源临时被分配了新的 URL，支持搜索引擎优化
* 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
* 304 not modified，自从上次请求后，请求的网页内容未修改过。服务器返回此响应时，不会返回网页内容。(「协商缓存」)
* 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求
***

**「（3）4XX 客户端错误」**
* 400 bad request，请求报文存在语法错误(传参格式不正确)
* 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息(没有权限)
* 403 forbidden，表示对请求资源的访问被服务器拒绝
* 404 not found，表示在服务器上没有找到请求的资源
* 408 Request Timeout 客户端请求超时
* 409 Confict 请求的资源可能引起冲突
***

**「（4）5XX 服务器错误」**
* 500 internal sever error，表示服务器端在执行请求时发生了错误
* 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
* 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

### 同样是重定向，「307」，「303」，「302」的区别
**「302」** 是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。

**「303」** 明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。

**「307」** 会遵照浏览器标准，不会从post变为get。

### DNS 协议是什么
**「概念」**：DNS 是「域名系统」 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

**「作用」**：将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。

### DNS完整的查询过程
DNS服务器解析域名的过程：
* 首先会在`「浏览器的缓存」`中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
* 将请求发送给`「本地DNS服务器」`，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
* 本地DNS服务器向`「根域名服务器」`发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
* 本地DNS服务器向`「顶级域名服务器」`发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
* 本地DNS服务器向`「权威域名服务器」`发送请求，域名服务器返回对应的结果
* 本地DNS服务器将返回结果保存在缓存中，便于下次使用
* 本地DNS服务器将返回结果返回给浏览器

### 简述一下TCP的三次握手
**「第一次握手：」** 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

**「第二次握手：」** 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**「第三次握手：」** 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

### TCP什么要三次握手呢？两次不行吗
* 为了确认双方的接收能力和发送能力都正常
* 如果是用两次握手，则会出现下面这种情况：

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

### 简述一下TCP的四次挥手

**「第一次挥手」**： 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。

**「第二次挥手」**：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。

**「第三次挥手」**：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。

**「第四次挥手」**： 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

###  TCP为什么需要四次挥手呢
因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。

### TCP粘包是怎么回事，如何处理
默认情况下, TCP 连接会启⽤「延迟传送算法」 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.

如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.

⽽对于处理粘包的问题, 常⻅的解决⽅案有:

**「多次发送之前间隔⼀个等待时间」**：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.

**「关闭 Nagle 算法」**：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。(如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)

**「进⾏封包/拆包」**： 封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。

### token是什么
1. token也可以称做「令牌」，一般由 uid+time+sign(签名)+[固定参数] 组成
```text
uid: 用户唯一身份标识
time: 当前时间的时间戳
sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接
固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库 
```

2. token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中

3. token 的认证流程
```text
用户登录，成功后服务器返回Token给客户端。
客户端收到数据后保存在客户端
客户端再次访问服务器，将token放入headers中 或者每次的请求 参数中
服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码
```

4. token可以抵抗csrf，cookie+session不行

5. session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session

6. 客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)
   
###  token是怎么加密的
1. 需要一个secret（随机数）
2. 后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端
3. 前端每次request在header中带上token
4. 后端用同样的算法解密

### cookie和token都放在header中，为什么会劫持cookie，不会劫持token

* `cookie`: 登陆后后端生成一个sessionid放在cookie中返回给客户端, 并且服务端一直记录着这个 sessionid, 客户端以后每次请求都会带上这个sessionid, 服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie就相当于拿到了sessionid ,就可以完全替代你。同时浏览器会自动携带cookie
* `token` : 同样是登录后服务端返回一个token，客户端保存起来，在以后http请求里手动的加入到请求头里，服务端根据token 进行身份的校验。浏览器不会自动携带token，所以不会劫持 token。

###  token过期后，页面如何实现无感刷新
**「什么是无感刷新」**

后台返回的token是有时效性的，时间到了，你在交互后台的时候，后台会判断你的token是否过期（安全需要），如果过期了就会逼迫你重新登陆！

**「token无感刷新其本质是为了优化用户体验,当token过期时不需要用户跳回登录页重新登录,而是当token失效时,进行拦截,发送刷新token的ajax,获取最新的token进行覆盖,让用户感受不到token已经过期」**

「实现无感刷新」

1、后端返回过期时间，前端判断token过期时间,去调用刷新token接口。

缺点：需要后端额外提供一个Token过期时间的字段；使用了本地时间判断，若本地时间篡改，特别是本地时间比服务器时间慢时，拦截会失败。

2、写个定时器，定时刷新Token接口。缺点：浪费资源,消耗性能,不建议采用。

3、在响应拦截器中拦截，判断Token 返回过期后，调用刷新token接口。

### 介绍下304过程
* a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。
* b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。
* c. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存

## 浏览器安全

### 有哪些可能引起前端安全的问题

**「跨站脚本」** (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；
**「iframe的滥⽤」**: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；
**「跨站点请求伪造」**（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击
**「恶意第三⽅库」**: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。

### 网络劫持有哪几种，如何防范
⽹络劫持分为两种:

（1）**「DNS劫持」**: (输⼊京东被强制跳转到淘宝这就属于dns劫持)
* DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
* 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容

（2）**「HTTP劫持」**: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)
DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。

### 进程与线程的概念
从本质上说，进程和线程都是 CPU 工作时间片的一个描述：

* 程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
* 程是进程中的更小单位，描述了执行一段指令所需的时间。
**「进程是资源分配的最小单位，线程是CPU调度的最小单位。」**

### 进程和线程的区别
* 进程可以看做独立应用，线程不能
* `「资源」`：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
* `「通信方面」`：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
* `「调度」`：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
* `「系统开销」`：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

### 如何实现浏览器内多个标签页之间的通信
实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：

* **「使用 websocket 协议」**，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
* **「使用 ShareWorker 的方式」**，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
* **「使用 localStorage 的方式」**，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。
* **「使用 postMessage 方法」**，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。

### 为什么需要浏览器缓存
对于浏览器的缓存，主要针对的是前端的静态资源，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。

所谓的 **「浏览器缓存」** 指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。

浏览器缓存的优点
使用浏览器缓存，有以下优点：

* 减少了服务器的负担，提高了网站的性能
* 加快了客户端网页的加载速度
* 减少了多余网络数据传输

### 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别
* **「点击刷新按钮或者按 F5」**： 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。
* **「用户按 Ctrl+F5（强制刷新）」**： 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。
* **「地址栏回车」**：浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

### 浏览器渲染过程中遇到 JS 文件如何处理
JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。

也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。

### 什么是文档的预解析
Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。

### CSS 如何阻塞文档解析
理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。

所以 **「如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。」** 也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。

### 浏览器本地存储的方式
**Cookie**
Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。`「Cookie的大小只有4kb」`，它是一种纯文本文件，`「每次发起HTTP请求都会携带Cookie。」`

**「Cookie的特性：」**
* Cookie一旦创建成功，名称就无法修改
* Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie
* 每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb
* 有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的
* Cookie在请求一个新的页面的时候都会被发送过去

**「如果需要域名之间跨域共享Cookie，有两种方法：」**

* 使用Nginx反向代理
* 在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId

**LocalStorage**
LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。

**「LocalStorage的优点：」**
* 在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息
* LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在
* 仅储存在本地，不像Cookie那样每次HTTP请求都会被携带

**「LocalStorage的缺点：」**
* 存在浏览器兼容问题，IE8以下版本的浏览器不支持
* 如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage
* LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问

**SessionStorage**
SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。

**「SessionStorage与LocalStorage对比：」**

* SessionStorage和LocalStorage都在 **「本地进行数据存储」**；
* SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage **「只有在同一浏览器的同一窗口下才能够共享」**；
* LocalStorage和SessionStorage **「都不能被爬虫爬取」**；

### Cookie、LocalStorage、SessionStorage区别

**「cookie」**： 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。

**「sessionStorage」** ：html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。

**「localStorage」** ：html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

### 什么是同源策略，什么是跨域
**「同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。」**

**「同源政策主要限制了三个方面：」**
* 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
* 当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
* 当前域下 ajax 无法发送跨域请求。

同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

**「什么是跨域」**
指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对 javascript 施加的安全限制，防止他人恶意攻击网站

**「跨域问题其实就是浏览器的同源策略造成的。」**

### 如何解决跨越问题
**「CORS」**
CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现「CORS的关键就是服务器，只要服务器实现了CORS请求」，就可以跨源通信了。
***
**「JSONP」**
「jsonp」的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据
**「优点」**
实现简单
兼容性好, 可用于解决主流浏览器的跨域数据访问的问题。

**「缺点」**
只支持 GET 请求 ( 因为
存在被 XSS 攻击的可能, 缺乏安全性保证
需要服务端配合改造
***
**「postMessage」**
postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

* 页面和其打开的新窗口的数据传递
* 多窗口之间消息传递
* 页面与嵌套的iframe消息传递
* 上面三个场景的跨域数据传递

`用法`：postMessage(data,origin)方法接受两个参数：
「data」：html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
「origin」：协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。
***
**「Node中间件代理(proxy正向代理)(两次跨域)」**
实现原理：「同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。」 代理服务器，需要做以下几个步骤：
* 接受客户端请求 。
* 将请求 转发给服务器。
* 拿到服务器 响应 数据。
***
**「nginx反向代理」**
实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。

使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

### 正向代理和反向代理的区别
* **「正向代理」**：
客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。

* **「反向代理」**：
服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。


![worker](/images/informal-essay10.png)

### 前端安全了解吗，说一下 XSS 和 CSRF，以及怎么规避
**「XSS」：跨域脚本攻击**
XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

攻击者可以通过这种攻击方式可以进行以下操作：

* 获取页面的数据，如DOM、cookie、localStorage；
* DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
* 破坏页面结构；
* 流量劫持（将链接指向某网站）；

**「防御方法」**
可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。

**「CSRF」：跨站请求伪造**
CSRF 攻击指的是 **「跨站请求伪造攻击」**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF 攻击的 **「本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。」**

**「CSRF 攻击可以使用以下方法来防护」**：

* `「进行同源检测」`，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。
* `「使用 CSRF Token 进行验证」`，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。
* `「对 Cookie 进行双重验证」`，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。
* `「在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用」`，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

**什么是中间人攻击？**
中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。

攻击过程如下:
* 客户端发送请求到服务端，请求被中间⼈截获
* 服务器向客户端发送公钥
* 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个「伪造的」公钥，发给客户端
* 客户端收到伪造的公钥后，⽣成加密hash值发给服务器
* 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器
* 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端

### 浏览器是如何进行界面渲染的
不同的渲染引擎的具体做法稍有差异，但是大体流程都是差不多的，下面以 chrome渲染引擎 的 渲染流程来说明：

1. 获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）
2. 解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）
3. 根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）
4. 进行布局（Layout）(重排)，即为每个节点分配⼀个在屏幕上应显示的确切坐标位置
5. 进⾏绘制（Paint）(重绘)，遍历渲染树节点，调⽤ GPU(图形处理器) 将元素呈现出来

###  前端如何实现即时通讯？websocket
**严格意义上: HTTP协议只能做到客户端请求服务器, 服务器做出响应, 做不到让服务器主动给客户端推送消息!**

**「那么如果服务器数据更新了, 想要即时通知到客户端怎么办呢 ? (即时通信需求)」**

即时通信需求: 服务器数据一有更新, 希望推送给到浏览器

提问的回答重心:

即时通信有哪些方案?
1.为什么使用了其中某一个方案! websocket
2. 基于Web的前端，存在以下几种可实现即时通讯的方式：

    * 短轮询 (历史方案)
    开个定时器, 每隔一段时间发请求 (实时性不强，影响性能)

    * Comet - ajax长轮询(历史方案)
    发送一个请求, 服务器只要数据不更新, 就一直阻塞 (服务器压力过大)

    *SSE
    (利用了http协议, 流数据的传输, 并不是严格意义的双向通信, 无法复用连接)

    *WebSocket (主流)
    性能和效率都高!

### 说一下websocket
**「websocket是一种网络通信协议」**，是HTML5开始提供的一种在单个TCP连接上进行全双工通信的协议，这个对比着HTTP协议来说，HTTP协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。

**「HTTP协议无法实现服务器主动向客户端发起消息」**，websocket连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。websocket只需要建立一次连接，就可以一直保持连接状态

**什么是轮询**
**「轮询：隔一段时间进行一次查询或者询问」**

轮询分为长轮询和短轮询，长轮询是基于短轮询的一个优化结果。

**「短轮询」**：
通过客户端定期轮询来询问服务端是否有新的信息产生，如果有则返回，没有就不响应， 缺点：也是显而易见，轮询间隔大了则信息不够实时，轮询间隔过小又会消耗过多的流量，增加服务器的负担。

**「长轮询」**：
是需要服务端进行更改来进行支持，客户端向服务端发送请求时，如果此时服务端没有新的信息产生，并不立刻返回，而是Hold住一段时间等有新的信息或者超时再返回，客户端收到服务器的应答后继续轮询。可以看到长轮询比短轮询可以减少大量无用的请求，并且客户端接收取新消息也会实时不少。减少http请求对性能的优化是很有利的，所以他是短轮询上的一个优化 缺点：终归来讲还是一个http请求，只是进行了变化而已，而且如果客户端不请求，服务端有数据的话，也会一直累积在那，不能实现实时的双向通信

此时的webSocket也就「应需而生」了

### 前端怎么做SEO优化
**「什么是SEO」**
SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。

**「为什么要做SEO」**

提高网站的权重，增强搜索引擎友好度，以达到提高排名，增加流量，改善（潜在）用户体验，促进销售的作用。

**「前端怎么做SEO优化」**

1. 网站结构布局优化: 尽量简单
    * 控制首页链接数量
    * 网页层级不要太深
    * 控制页面大小, 减少HTTP请求, 提高网站的加载速度
    * 尽量使用语义化标签
    * 利用浏览器缓存
    
    
    
## 什么是重绘和重排？
### **一、页面渲染的流程**

* 解析html绘制DOM树

* 解析css绘制CSS树

* 把DOM和CSSOM组合生成render tree（渲染树）

* 在渲染树的基础上进行布局，计算每个节点的几何结构

* 把每个节点绘制到屏幕上（painting）

DOM发生改变的时候触发重排，使DOM重新排列，重绘不一定会重排，但重排一定会发生重绘，重绘和重排都会耗费浏览器的性能，尽量避免。

### **二、什么是重排和重绘**
**重绘就是重新绘制（repaint）**：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

**重排就是重新排列（reflow）**：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

### **三、重排**

**1. 引起重排的属性和方法**

改变元素几何信息（大小和位置），都会引起，如：
* 添加或删除可见的DOM元素

* 元素位置改变，或者使用动画

* 元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）

* 内容改变（例如：文本改变或图片被另一个不同尺寸的图片替代、在input框输入内容）

* 浏览器窗口尺寸改变（resize事件发生时）

* 页面渲染初始化

* 设置style属性的值

* 计算offsetWidth、offsetHeight、offsetTop和offsetLeft等布局信息

* 激活CSS伪类（如 :hover）

* 查询某些属性或调用某些方法（如：getComputedStyle()、getBoundingClientRect()）

**2、几何属性和布局信息的属性有哪些？**

几何属性包括布局、尺寸等可用数学几何衡量的属性：

* 布局：display、float、position、list、table、flex、columns、grid

* 尺寸：margin、padding、border、width、height

获取布局信息的属性或方法：

* offsetTop、offsetLeft、offsetWidth、offsetHeight

* scrollTop、scrollLeft、scrollWidth、scrollHeight

* clientTop、clientLeft、clientWidth、clientHeight

* getComputedStyle()

* getBoundingClientRect()

### 四、重绘
**引起重绘的属性：**

外观属性包括界面、文字等可用状态向量描述的属性，如：

* 界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip、border-radius、background-size、visibility

* 文字：text、font、word

### 五、减少重排和重绘
* 避免一条一条的修改DOM的样式，可以直接修改DOM的className

* 避免把DOM结点的属性值放在一个循环里当成循环里的变量

* 给动画的HTML元件使用fixed或absolute的position，那么修改他们的css是不会重排

* 避免在大量元素上使用:hover

* 分离读写操作

* 避免使用Table布局

* 避免设置多层内联样式

* 避免在布局信息改变时查询布局信息

* 当需要对DOM元素进行一系列的操作时，可以先使元素脱离文档流，再对其进行一些列操作，然后再把元素带回文档中

### 六、使元素脱离文档流的方法：
* 隐藏元素，施加修改，重新显示

* 使用document fragment在当前DOM之外构建一个子树，再把它拷贝会文档

* 将元素元素拷贝到另一个脱离文档的节点中，修改副本，完成后再替换原始元素

## socket和http区别
**主体不同**
**socket**：socket不属于协议范畴，而是一个调用接口（API），是对TCP/IP协议的封装。实现服务器与客户端之间的物理连接，并进行数据传输。

**http**：HTTP是基于TCP/IP协议的应用层协议，定义的是传输数据的内容的规范。
***

**所处层次不同**
**socket**：Socket处于网络协议的传输层，主要有TCP/UDP两个协议（当然也有TCP/IP协议族中其他的协议）。

**http**：HTTP是基于TCP/IP协议的应用层协议。
***

**连接状态不同**
**socket**：socket连接是长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会使连接断开，比如：服务器端或客户端主机宕机了、网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。所以当一个socket连接中没有数据的传输，那么为了维持连接需要发送心跳消息。

**http**：HTTP是基于请求-响应形式并且是短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉。HTTP是无状态的协议，针对其无状态特性，在实际应用中又需要有状态的形式，因此一般会通过session/cookie技术来解决此问题。
***

**传输数据量不同**
**socket**：socket传输的数据可自定义，为字节级，数据量小。

**http**：HTTP的传输速度慢，数据包大。
***

**数据安全性不同**
**socket**：数据可以加密，数据安全性高，适合Client/Server之间信息实时交互。

**http**：数据传输安全性差，如实现实时交互，服务器性能压力大。
***

**连接方式不同**
**socket**：Socket是客户端跟服务器直接使用Socket”套接字”进行连接，并没有规定连接后断开，所以客户端和服务器可保持连接通道，双方都可以主动发送数据。

**http**：http是客户端用http协议进行请求，发送请求的时候需要封装http请求头，并绑定请求的数据，服务器一般有web服务器配合(当然也非绝对)，http的请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源，服务器不能主动给客户端发起响应，主要使用类是NSURLConnection。


### socket的主要类型
* **流套接字(SOCK_STREAM)：** 流套接字用于提供面向连接、可靠的数据传输服务。该服务将保证数据能够实现无差错、无重复送，并按顺序接收。流套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即TCP(The Transmission Control Protocol)协议。
* **数据报套接字(SOCK_DGRAM)：** 数据报套接字提供一种无连接的服务。该服务并不能保证数据传输的可靠性,数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP( User DatagramProtocol)协议进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。
* **原始套接字(SOCK_RAW)：** 原始套接字与标准套接字(标准套接字指的是前面介绍的流套接字和数据报套接字)的区别在于：原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送的数据必须使用原始套接。

## 事件循环（Event Loop）
3

## 2023面试部分合集
**DIFF 算法的原理**
在新老虚拟 `DOM` 对比时：
首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则
删除该节点重新创建节点进行替换
如果为相同节点，进行 `patchVnode`，判断如何对该节点的子节点进
行处理，先判断一方有子节点一方没有子节点的情况(如果新的
`children` 没有子节点，将旧的子节点移除)
比较如果都有子节点，则进行 `updateChildren`，判断如何对这些新
老节点的子节点进行操作（`diff` 核心）。
匹配时，找到相同的子节点，递归比较子节点
在 `diff` 中，只对同层的子节点进行比较，放弃跨级的节点比较，使
得时间复杂从 O(n
3)降低值 O(n)，也就是说，只有当新旧 `children`
都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。

### **懒加载的概念**
**懒加载**也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片
数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，
如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口
的那一部分图片数据，这样就浪费了性能。
如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视
化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网
页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，
页面列表较长（长列表）的场景中。
**懒加载的特点**
**减少无用资源的加载**：使用懒加载明显减少了服务器的压力和流量，
同时也减小了浏览器的负担。
**提升用户体验**: 如果同时加载较多图片，可能需要等待的时间较长，
这样影响了用户体验，而使用懒加载就能大大的提高用户体验。
防止加载过多图片而影响其他资源文件的加载 ：会影响网站应用的
正常使用。
**懒加载的实现原理**
图片的加载是由 `src` 引起的，当对 `src` 赋值时，浏览器就会请求图片
资源。根据这个原理，我们使用 `HTML5` 的 `data-xxx` 属性来储存图片
的路径，在需要加载图片的时候，将 `data-xxx `中图片的路径赋值给
`src`，这样就实现了图片的按需加载，即懒加载。
注意：`data-xxx` 中的 `xxx` 可以自定义，这里我们使用 `data-src` 来定
义。
懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可
视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，
获取图片的真实地址并赋值给图片即可。
使用原生 `JavaScript` 实现懒加载：
知识点：
`window.innerHeight` 是浏览器可视区的高度
`document.body.scrollTop`
`document.documentElement.scrollTop` 是浏览器滚动的过的距离
`imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距
离）
图 片 加 载 条 件 ： `img.offsetTop < window.innerHeight + document.body.scrollTop`;
代码如下：

```html
<div class="container">
<img src="loading.gif" data-src="pic.png">
<img src="loading.gif" data-src="pic.png">
<img src="loading.gif" data-src="pic.png">
<img src="loading.gif" data-src="pic.png">
<img src="loading.gif" data-src="pic.png">
<img src="loading.gif"data-src="pic.png">
</div>
<script>
let imgs = document .querySelectorAl1('img');
function lozyLoad() {
    let scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    let winHeight= window.innerHeight;
    for(let i=0;i < imgs.length;i++) {
    if(imgs[i].offsetTop < scrollTop + winHeight ){
        imgs[i].src = imgs[i].getAttribute("data-src");
        }
    }
}
window.onscroll= lozyLoad();
</script>
```
### 回流与重绘的概念及触发条件
（1）回流
当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。
下面这些操作会导致回流：
* 页面的首次渲染
* 浏览器的窗口大小发生变化
* 元素的内容发生变化
* 元素的尺寸或者位置发生变化
* 元素的字体大小发生变化
* 激活CSS伪类
* 查询某些属性或者调用某些方法
* 添加或者删除可见的DOM元素

在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的`DOM`元素重新排列，它的影响范围有两种：
全局范围：从根节点开始，对整个渲染树进行重新布局
局部范围：对渲染树的某部分或者一个渲染对象进行重新布局
（2）重绘
当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。
下面这些操作会导致重绘：
下面这些操作会导致重绘：
`color`、`background` 相关属性：`background-color`、`background-image`等
`outline` 相 关 属 性 ： `outline-color` 、 `outline-width` 、`text-decoration`
`border-radius`、`visibility`、`box-shadow`
注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回
流。

**如何避免回流与重绘？**
减少回流与重绘的措施：
1. 操作 `DOM` 时，尽量在低层级的 `DOM` 节点进行操作不要使用 `table` 布局， 一个小的改动可能会使整个 `table` 进行重新
布局
2. 使用 `CSS` 的表达式不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样
式。
3. 使用 `absolute` 或者 `fixed`，使元素脱离文档流，这样他们发生变化就不会影响其他元素
避免频繁操作 `DOM`，可以创建一个文档片段 `documentFragment`，在它
上面应用所有 `DOM` 操作，最后再把它添加到文档中
将元素先设置 `display: none`，操作结束后再把它显示出来。因为在
`display` 属性为 `none` 的元素上进行的 `DOM` 操作不会引发回流和重绘。
将 `DOM` 的多个读操作（或者写操作）放在一起，而不是读写操作穿插
着写。这得益于浏览器的渲染队列机制。
浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列
浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操
作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行
批处理。这样就会让多次的回流、重绘变成一次回流重绘。
上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作
进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发
一次回流。

### **如何优化动画？**
对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作
`DOM`，就就会导致页面的性能问题，我们可以将动画的 `position` 属性
设置为 `absolute` 或者 `fixed`，将动画脱离文档流，这样他的回流就
不会影响到页面了。
**`documentFragment` 是什么？用它跟直接操作 `DOM` 的区别是什么？**
`MDN` 中对 `documentFragment` 的解释：
`DocumentFragment`，文档片段接口，一个没有父对象的最小文档对象。
它被作为一个轻量版的 `Document` 使用，就像标准的 `document` 一样，
存储由节点（`nodes`）组成的文档结构。与 `document` 相比，最大的区
别是 `DocumentFragment` 不是真实 DOM 树的一部分，它的变化不会触
发 `DOM` 树的重新渲染，且不会导致性能等问题。
当我们把一个 `DocumentFragment` 节点插入文档树时，插入的不是
`DocumentFragment` 自身，而是它的所有子孙节点。在频繁的 DOM 操
作时，我们就可以将 DOM 元素插入 `DocumentFragment`，之后一次性
的将所有的子孙节点插入文档中。和直接操作 `DOM` 相比，将
`DocumentFragment` 节点插入 `DOM` 树时，不会触发页面的重绘，这样
就大大提高了页面的性能。

### **对节流与防抖的理解**
`函数防抖`是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事
件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避
免因为用户的多次点击向后端发送多次请求。
防抖函数的应用场景：
按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次
服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊
事 件 的 最 后 ⼀ 次 ， 还 有 搜 索 联 想 词 功 能 类 似 ⽣ 存 环 境 请 ⽤
`lodash.debounce`
***
`函数节流`是指规定一个单位时间，在这个单位时间内，只能有一次触
发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，
只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过
事件节流来降低事件调用的频率。
节流函数的适⽤场景：
* 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动
* 缩放场景：监控浏览器 `resize`
* 动画场景：避免短时间内多次触发动画引起性能问题

**实现节流函数和防抖函数**
函数防抖的实现：
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <input type="text" id="input" />
        <script>
            let input = document.querySelector('#input');
            input.addEventListener('keyup', debounce(submit, 1500, true));
 
            function submit(e) {
                console.log(e.target.value);
            }
            // 在防抖函数中第三个参数immediate，可以实现这种效果
            function debounce(func, delay, immediate) {
                let timer;
                return function () {
                    if (timer) clearTimeout(timer);
                    if (immediate) {
                        // 复杂的防抖函数
                        // 判断定时器是否为空，如果为空，则会直接执行回调函数
                        let firstRun = !timer;
                        // 不管定时器是否为空，都会重新开启一个新的定时器,不断输入，不断开启新的定时器，当不在输入的delay后，再次输入就会立即执行回调函数
                        timer = setTimeout(() => {
                            timer = null;
                        }, delay);
                        if (firstRun) {
                            func.apply(this, arguments);
                        }
                        // 简单的防抖函数
                    } else {
                        timer = setTimeout(() => {
                            func.apply(this, arguments);
                        }, delay);
                    }
                };
            }
        </script>
    </body>
</html>
```
函数节流的实现：
```js
//函数返回值
function throttle(fn, interval, options = {leading: true,trailing: false}) {
    //1.记录上一次的开始时间
    let lastTime = 0
    let timer = null
    const {
        leading,
        trailing,
        resultCallback
    } = options
    //2.事件触发时，真正的执行函数
    const _throttle = function (...args) {
        return new Promise((resolve, reject) => {
            //2.1 获取当前事件触发时的时间
            const nowTime = new Date().getTime()
 
            if (!lastTime && !leading) lastTime = nowTime
            //2.2 使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数
            const remainTime = interval - (nowTime - lastTime)
            if (remainTime <= 0) {
                if (timer) {
                    clearTimeout(timer)
                    timer = null
                }
                //2.3 真正触发函数
                const result = fn.apply(this, args)
                if (resultCallback) resultCallback(result)
                resolve(result)
                //2.4 保留上次触发的时间
                lastTime = nowTime
                return
            }
            //2.3 最后一次是否执行
            if (trailing && !timer) {
                timer = setTimeout(() => {
                    timer = null
                    lastTime = !leading ? 0 : new Date().getTime()
                    const result = fn.apply(this, args)
                    if (resultCallback) resultCallback(result)
                    resolve(result)
                }, remainTime)
            }
        })
 
    }
    _throttle.cancel = function () {
        if (timer) clearTimeout(timer)
        timer = null
        lastTime = 0
    }
    return _throttle
}
```

### **如何对项目中的图片进行优化？**
1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替照片使用 JPEG

**常见的图片格式及使用场景**
1. `BMP`，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以 `BMP` 格式的图片通常是较大的文件。
2. `GIF` 是无损的、采用索引色的点阵图。采用 `LZW` 压缩算法进行编码。文件小，是 `GIF` 格式的优点，同时，`GIF` 格式还具有支持动画以及透明的优点。但是 `GIF` 格式仅支持 `8bit` 的索引色，所以 `GIF` 格式适用于对色彩要求不高同时需要文件体积较小的场景。
3. `JPEG` 是有损的、采用直接色的点阵图。`JPEG` 的图片的优点是采用了直接色，得益于更丰富的色彩，`JPEG` 非常适合用来存储照片，与 `GIF` 相比，`JPEG` 不适合用来存储企业 `Logo`、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较 `GIF` 更大。
4. `PNG-8` 是无损的、使用索引色的点阵图。`PNG` 是一种比较新的图片格式，`PNG-8` 是非常好的 `GIF` 格式替代者，在可能的情况下，应该尽可能的使用 `PNG-8` 而不是 `GIF`，因为在相同的图片效果下，`PNG-8`具有更小的文件体积。除此之外，`PNG-8` 还支持透明度的调节，而 `GIF` 并不支持。除非需要动画的支持，否则没有理由使用 `GIF` 而不是 `PNG-8`。
5. `PNG-24` 是无损的、使用直接色的点阵图。`PNG-24` 的优点在于它压缩了图片的数据，使得同样效果的图片，`PNG-24` 格式的文件大小要比 `BMP` 小得多。当然，`PNG24` 的图片还是要比 `JPEG`、`GIF`、`PNG-8`大得多。
6. `SVG` 是无损的矢量图。`SVG` 是矢量图意味着 `SVG` 图片由直线和曲线以及绘制它们的方法组成。当放大 `SVG` 图片时，看到的还是线和曲线，而不会出现像素点。这意味着 `SVG` 图片在放大时，不会失真，所以它非常适合用来绘制 `Logo`、`Icon` 等。
7. `WebP` 是谷歌开发的一种新图片格式，`WebP` 是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为 `Web` 而生的，什么叫为 `Web` 而生呢？就是说相同质量的图片，`WebP` 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有 `Chrome` 浏览器和 `Opera`浏览器支持 `WebP` 格式，兼容性不太好。
   * 在无损压缩的情况下，相同质量的 `WebP` 图片，文件大小要比 `PNG` 小26%；
   * 在有损压缩的情况下，具有相同图片精度的 `WebP` 图片，文件大小要比 `JPEG` 小 25%~34%；
   * WebP 图片格式支持图片透明度，一个无损压缩的 `WebP` 图片，如果要支持透明度只需要 22%的格外文件大小。

### 如何⽤webpack 来优化前端性能？
⽤ `webpack` 优化前端性能是指优化 `webpack` 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。

压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤ `webpack` 的 `UglifyJsPlugin` 和 `ParallelUglifyPlugin` 来压缩
JS⽂件， 利⽤ `cssnano （css-loader?minimize）`来压缩 `css`利⽤`CDN` 加速: 在构建过程中，将引⽤的静态资源路径修改为 `CDN` 上
对应的路径。可以利⽤ `webpack` 对于 `output` 参数和各 `loader` 的 `publicPath` 参数来修改资源路径

`Tree Shaking`: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 `webpack` 时追加参数 `--optimize-minimize` 来实现

`Code Splitting`: 将代码按路由维度或者组件分块(`chunk`),这样做到按需加载,同时可以充分利⽤浏览器缓存

提取公共第三⽅库: `SplitChunksPlugin` 插件来进⾏公共模块抽取, 利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码

### 如何提⾼webpack 的构建速度？
1. 多⼊⼝情况下，使⽤ `CommonsChunkPlugin` 来提取公共代码
2. 通过 `externals` 配置来提取常⽤库
3. 利⽤ `DllPlugin` 和 `DllReferencePlugin` 预编译资源模块 通过 `DllPlugin` 来对那些我们引⽤但是绝对不会修改的 `npm` 包来进⾏预编译，再通过 `DllReferencePlugin` 将预编译的模块加载进来。
4. 使⽤ `Happypack` 实现多线程加速编译
5. 使⽤ `webpack-uglify-parallel` 来提升 `uglifyPlugin` 的压缩速度。原理上 `webpack-uglify-parallel`采⽤了多核并⾏压缩来提升压缩速度
6. 使⽤ `Tree-shaking` 和 `Scope Hoisting` 来剔除多余代码


## **前端工程化部分**
1. `webpack` 与 `grunt`、`gulp` 的不同？
`Grunt`、`Gulp` 是基于任务运⾏的⼯具： 它们会⾃动执⾏指定的任务，
就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活
跃的社区，丰富的插件，能⽅便的打造各种⼯作流。
`Webpack` 是基于模块化打包的⼯具: `⾃动化处理模块，webpack` 把⼀
切当成模块，当 `webpack` 处理应⽤程序时，它会递归地构建⼀个依
赖关系图 (`dependency graph`)，其中包含应⽤程序需要的每个模块，
然后将所有这些模块打包成⼀个或多个 `bundle。`
因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤`npm script` 代
替 `Grunt`、`Gulp`，`npm script` 同样可以打造任务流。
2. `webpack、rollup、parcel` 优劣？
`webpack` 适⽤于⼤型复杂的前端站点构建: `webpack` 有强⼤的 `loader`
和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即
执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，
值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块
等,这种情况更适合⽂件依赖复杂的应⽤开发。
`rollup` 适⽤于基础库的打包，如 `vue、d3` 等: `Rollup` 就是将各个模
块打包进⼀个⽂件中，并且通过 `Tree-shaking` 来删除⽆⽤的代码, 可以最⼤程度上降低代码体积,但是 `rollup` 没有 `webpack` 如此多的的
如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适
合库的开发。
`parcel` 适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效
果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项
⽬或者实验项⽬不建议使⽤。
3. 有哪些常⻅的 `Loader？`
`file-loader`：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL
去引⽤输出的⽂件
`url-loader`：和 `file-loader` 类似，但是能在⽂件很⼩的情况下以
`base64` 的⽅式把⽂件内容注⼊到代码中去
`source-map-loader`：加载额外的 `Source Map` ⽂件，以⽅便断点调
试
`image-loader`：加载并且压缩图⽚⽂件
`babel-loader`：把 `ES6` 转换成 `ES5`
`css-loader`：加载 `CSS`，⽀持模块化、压缩、⽂件导⼊等特性
`style-loader`：把 `CSS` 代码注⼊到 `JavaScript` 中，通过 DOM 操作
去加载 CSS。
`eslint-loader`：通过 `ESLint` 检查 `JavaScript` 代码
注意：在 `Webpack` 中，`loader` 的执行顺序是从右向左执行的。因为
webpack 选择了 `compose` 这样的函数式编程方式，这种方式的表达式
执行是从右向左的。

4. 有哪些常⻅的 `Plugin`？
`define-plugin`：定义环境变量
`html-webpack-plugin`：简化 `html` ⽂件创建
`uglifyjs-webpack-plugin`：通过 `UglifyES` 压缩 `ES6` 代码
`webpack-parallel-uglify-plugin`: 多核压缩，提⾼压缩速度
`webpack-bundle-analyzer`: 可视化 `webpack` 输出⽂件的体积
`mini-css-extract-plugin`: `CSS` 提取到单独的⽂件中，⽀持按需加
载

5. `bundle，chunk，module` 是什么？
`bundle`：是由 `webpack` 打包出来的⽂件；
`chunk`：代码块，⼀个 `chunk` 由多个模块组合⽽成，⽤于代码的合并
和分割；
`module`：是开发中的单个模块，在 `webpack` 的世界，⼀切皆模块，⼀
个模块对应⼀个⽂件，`webpack` 会从配置的 `entry` 中递归开始找出所
有依赖的模块。

6. `Loader` 和 `Plugin` 的不同？
不同的作⽤:
`Loader` 直译为"加载器"`。Webpack` 将⼀切⽂件视为模块，但是 webpack原⽣是只能解析 js⽂件，如果想将其他⽂件也打包的话，就会⽤到`loader` 。 所以 `Loader` 的作⽤是让 `webpack` 拥有了加载和解析⾮`JavaScript`⽂件的能⼒。

`Plugin` 直译为"插件"`。Plugin` 可以扩展 webpack 的功能，让 `webpack` 具有更多的灵活性。在 `Webpack` 运⾏的⽣命周期中会⼴播出许多事件，`Plugin` 可以监听这些事件，在合适的时机通过 `Webpack` 提供的 `API` 改变输出结果。

不同的⽤法:
`Loader` 在 `module.rules` 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 `Object` ，⾥⾯描述了对于什么类型的⽂件（ `test` ），使⽤什么加载( `loader` )和使⽤的参数（ `options` ）

`Plugin` 在 `plugins` 中单独配置。类型为数组，每⼀项是⼀个 `plugin` 的实例，参数都通过构造函数传⼊。

7. `webpack` 热更新的实现原理？
`webpack` 的热更新⼜称热替换（`Hot Module Replacement`），缩写为`HMR`。这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。

原理：
![`webpack` 热更新的实现原理](/images/mst01.png)


⾸先要知道 `server` 端和 `client` 端都做了处理⼯作：
* 第⼀步，在 `webpack` 的 `watch` 模式下，⽂件系统中某⼀个⽂件发⽣修改，`webpack` 监听到⽂件变化，根据配置⽂件对模块重新编译打包，并将打包后的代码通过简单的 `JavaScript`对象保存在内存中。

* 第⼆步是 `webpack-dev-server` 和 `webpack` 之间的接⼝交互，⽽在这⼀步，主要是 `dev-server` 的中间件 `webpack- dev-middleware`和 `webpack` 之间的交互，`webpack-dev-middleware` 调⽤ `webpack`暴露的 `API` 对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。

* 第三步是 `webpack-dev-server` 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了 `devServer.watchContentBase` 为 `true` 的时候，`Server` 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进⾏ `live reload`。注意，这⼉是浏览器刷新，和 `HMR` 是两个概念。第四步也是 `webpack-dev-server` 代码的⼯作，该步骤主要是通过`sockjs`（`webpack-dev-server` 的依赖）在浏览器端和服务端之间建⽴⼀个 `websocket` ⻓连接，将 `webpack` 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 `Server` 监听静态⽂件变化的信息。浏览器端根据这些 `socket` 消息进⾏不同的操作。当然服务端传递的最主要信息还是新模块的 `hash` 值，后⾯的步骤根据这⼀hash 值来进⾏模块热替换。

`webpack-dev-server/client` 端并不能够请求更新的代码，也不会执⾏热更模块操作，⽽把这些⼯作⼜交回给了 `webpack` ，`webpack/hot/dev-server` 的 ⼯ 作 就 是 根 据`webpack-dev-server/client` 传给它的信息以及 `dev-server` 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。

`HotModuleReplacement.runtime` 是客户端 `HMR` 的中枢，它接收到上
⼀ 步 传 递 给 他 的 新 模 块 的 hash 值 ， 它 通 过`JsonpMainTemplate.runtime` 向 `server` 端发送 `Ajax` 请求，服务端返回⼀个 `json`，该 `json` 包含了所有要更新的模块的 `hash` 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。

⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，`HotModulePlugin` 将会对新旧模块进⾏对⽐，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。

最后⼀步，当 `HMR` 失败后，回退到 `live reload` 操作，也就是进⾏浏览器刷新来获取最新打包代码。

8. `Babel` 的原理是什么?
`babel` 的转译过程也分为三个阶段，这三步具体是：
`解析 Parse`: 将代码解析⽣成抽象语法树（AST），即词法分析与语
法分析的过程；
`转换 Transform`: 对于 AST 进⾏变换⼀系列的操作，`babel` 接受得
到 AST 并通过 `babel-traverse` 对其进⾏遍历，在此过程中进⾏添
加、更新及移除等操作；
⽣成 `Generate`: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模
块是 `babel-generator`。

![原理](/images/mst02.png)



9. git 和 svn 的区别
git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器出现问题，就没有办法使用 svn 来提交代码。

svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。

svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。

GIT 把内容按元数据方式存储，而 SVN 是按文件：因为 git 目录是处于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。

GIT 分支和 SVN 的分支不同：svn 会发生分支遗漏的情况，而 git 可以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并的分支，简单而快捷的合并这些文件。

GIT 没有一个全局的版本号，而 SVN 有GIT 的内容完整性要优于 SVN：GIT 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏

11. `git pull` 和 `git fetch` 的区别
`git fetch` 只是将远程仓库的变化下载下来，并没有和本地分支合并。
`git pull` 会将远程仓库的变化下载下来，并和当前分支合并。

12. `git rebase` 和 `git merge` 的区别
`git merge` 和 `git rebase` 都是用于分支合并，关键在 `commit` 记录
的处理上不同：
`git merge` 会新建一个新的 `commit` 对象，然后两个分支以前的
`commit` 记录都指向这个新 `commit` 记录。这种方法会保留之前每个
分支的 `commit` 历史。
`git rebase` 会先找到两个分支的第一个共同的 `commit` 祖先记录，
然后将提取当前分支这之后的所有 `commit` 记录，然后将这个
`commit` 记录添加到目标分支的最新提交后面。经过这个合并后，两
个分支合并后的 `commit` 记录就变为了线性的记录了。

## 浏览器部分
1. 什么是 XSS 攻击？
**（1）概念**
`XSS` 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 `cookie` 等。

`XSS` 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

攻击者可以通过这种攻击方式可以进行以下操作：
1. 获取页面的数据，如 DOM、cookie、localStorage；
2. DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
3. 破坏页面结构；
4. 流量劫持（将链接指向某网站）；

**（2）攻击类型**
XSS 可以分为存储型、反射型和 DOM 型：
存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。

反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成

*XSS 攻击。*
DOM 型指的通过修改页面的 DOM 节点形成的 XSS。
1）存储型 XSS 的攻击步骤：
1.攻击者将恶意代码提交到⽬标⽹站的数据库中。
2.⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接
在 HTML 中返回给浏览器。
3.⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
4.恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏
为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评
论、⽤户私信等。
2）反射型 XSS 的攻击步骤：
1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL
中取出，拼接在 HTML 中返回给浏览器。
3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏
为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。

反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。
**3）DOM 型 XSS 的攻击步骤：**
1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. ⽤户打开带有恶意代码的 URL。
3. ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL
中的恶意代码并执⾏。
4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏
为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执
⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，
⽽其他两种 XSS 都属于服务端的安全漏洞。

2. 如何防御 XSS 攻击？
可以看到 XSS 危害如此之大，那么在开发网站时就要做好防御措施，
具体措施如下：
可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服
务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到
HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚
本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对
可能出现的恶意代码情况进行判断。
使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资
源可以加载和执行，从而防止恶意代码的注入攻击。
1. CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
2. 通常有两种方式来开启 `CSP，一种是设置` `HTTP` 首部中的`Content-Security-Policy`，一种是设置 `meta` 标签的方式 `<meta http-equiv="Content-Security-Policy">`
对一些敏感信息进行保护，比如 `cookie` 使用 `http-only`，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。

3. 什么是 `CSRF` 攻击？
（1）概念
`CSRF` 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三
方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击
网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过
后台的用户验证，冒充用户向服务器执行一些操作。
`CSRF` 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器
的特点，以此来实现用户的冒充。
（2）攻击类型
常见的 `CSRF` 攻击有三种：
`GET` 类型的 `CSRF` 攻击，比如在网站中的一个 img 标签里构建一个
请求，当用户打开这个网站的时候就会自动发起提交。
`POST` 类型的 `CSRF` 攻击，比如构建一个表单，然后隐藏它，当用户
进入页面时，自动提交这个表单。
链接类型的 `CSRF` 攻击，比如在 a 标签的 href 属性里构建一个请
求，然后诱导用户去点击。

4. 如何防御 CSRF 攻击？
CSRF 攻击可以使用以下方法来防护：
进行同源检测，服务器根据 http 请求头中 origin 或者 referer
信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当
origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方
式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎
的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是
相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字
段会告诉服务器该网页是从哪个页面链接过来的）
使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token ，
当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，
然后服务器对这个 token 进行验证。这种方法解决了使用 cookie
单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点
就是，我们需要给网站中的所有请求都添加上这个 token，操作比较
繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过
负载平衡转移到了其他的服务器，但是这个服务器的 session 中没
有保留这个 token 的话，就没有办法验证了。这种情况可以通过改
变 token 的构建方式来解决。
对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域
名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器
发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数
中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，
来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是
不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法
更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果
网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做
到子域名的隔离。
在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为
被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种
模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可
能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是
GET 请求，且会发生页面跳转的请求所使用。
5. 有哪些可能引起前端安全的问题?
跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了
与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没
有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖
⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不
限于 JavaScript / CSS / Flash 等；
iframe 的滥⽤: iframe 中的内容是由第三⽅来提供的，默认情况下
他们不受控制，他们可以在 iframe 中运⾏JavaScirpt 脚本、Flash
插件、弹出对话框等等，这可能会破坏前端⽤户体验；
跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击
者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信
息或设定信息等某些状态更新，属于被动攻击
恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数
时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被
植⼊恶意代码很容易引起安全问题。
6. 网络劫持有哪几种，如何防范？
⽹络劫持分为两种:
（1）DNS 劫持: (输⼊京东被强制跳转到淘宝这就属于 dns 劫持)
DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导⽤户流量到
缓存服务器
302 跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可
以进⾏劫持处理的,再对劫持的内存发起 302 跳转的回复，引导⽤户
获取内容
（2）HTTP 劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于 http
明⽂传输,运营商会修改你的 http 响应内容(即加⼴告)
（3）DNS 劫持由于涉嫌违法，已经被监管起来，现在很少会有 DNS
劫持，⽽http 劫持依然⾮常盛⾏，最有效的办法就是全站 HTTPS，将
HTTP 加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。













