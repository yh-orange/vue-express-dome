## css滤镜filter函数，让照片随意变色，一个属性让网站变黑白效果，就这样任性

**一、常用filter函数，语法【filter：xxx】**

1. blur()，函数将高斯模糊应用于输入图像；

2. contrast()，函数可调整输入图像的对比度，值是 0% 的话，图像会全黑。值是 100%，图像不变。值可以超过 100%，意味着会运用更低的对比。若没有设置值，默认是 1；

3. grayscale()，函数将改变输入图像灰度。amount 的值定义了转换的比例。值为 100% 则完全转为灰度图像，值为 0% 图像无变化。值在 0% 到 100% 之间，则是效果的线性乘数。若未设置值，默认是 0；

4. drop-shadow()，函数对输入图像应用阴影效果；

5. hue-rotate()，函数在输入图像上应用色相旋转。

dome
```html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            /* grayscale百分比越大，黑白感越强烈 */
            /* filter: grayscale(110%); */
        }
        ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            padding: 0;
        }
        .logo {
            width: 100%;
            height: 100%;
        }
        .filter { filter: blur(5px); }
        .filter1 { filter: contrast(200%); }
        .filter2 { filter: grayscale(80%); }
        .filter3 { filter: hue-rotate(90deg); }
        .filter4 { filter: drop-shadow(0 0 2em #646cffaa) }
        .li-image {
            position: relative;
            width: 301px;
            height: 301px;
            margin: 5px;
        }
        .li-image > .filter-name {
            color: red;
            font-size: 30px;
            position: absolute;
            left: 42px;
            top: 15px;
        }
</style>
</head>
<body align="center">
    <ul>
        <li class="li-image">
            <img class="logo" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">无滤镜</span>
        </li>
        <li class="li-image">
            <img class="logo filter" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">blur(5px)</span>
        </li>
        <li class="li-image">
            <img class="logo filter1" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">contrast(200%);</span>
        </li>
        <li class="li-image">
            <img class="logo filter2" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">grayscale(80%);</span>
        </li>
        <li class="li-image">
            <img class="logo filter3" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">hue-rotate(90deg);</span>
        </li>
        <li class="li-image">
            <img class="logo filter4" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">drop-shadow(0 0 2em #646cffaa)</span>
        </li>
    </ul>
</body>
</html>
```

**滤镜调试技巧：编写基础滤镜样式，用浏览器打开，f12控制台，鼠标点击控制台工具左上角三角形图标，然后选择对应带滤镜的element元素，就会看到滤镜样式，调节滤镜值大小就能实时看到效果。**


**一个属性让网站变黑白效果**

`注意：body开启filter: grayscale(110%);属性后，所有html标签样式都会失效。`

```css
body {
      /* grayscale百分比越大，黑白感越强烈 */
     filter: grayscale(110%);
}
```

## JavaScript中,{}+{}等于多少?

**JavaScript-wat**
在 `JavaScript` 中,加法的规则其实很简单,只有两种情况:你只能把数字和数字相加,或者字符串和字符串相加,所有其他类型的值都会被自动转换成这两种类型的值. 为了能够弄明白这种隐式转换是如何进行的,我们首先需要搞懂一些基础知识.注意:在下面的文章中提到某一章节的时候(比如§9.1),指的都是ECMA-262语言规范([ECMAScript 5.1](https://262.ecma-international.org/5.1/))中的章节.

让我们快速的复习一下.在JavaScript中,一共有两种类型的值:原始值(`primitives`)和对象值(`objects`).原始值有:`undefined`, `null`, `布尔值(booleans)`, `数字(numbers)`,还有`字符串(strings)`.其他的所有值都是对象类型的值,包括数组(`arrays`)和函数(`functions`).

## Web Worker
在HTML5的新规范中，实现了 Web Worker 来引入 js 的 “多线程” 技术, 可以让我们可以在页面主运行的 js 线程中加载运行另外单独的一个或者多个 js 线程。

**一句话： Web Worker专门处理复杂计算的，从此让前端拥有后端的计算能力**
1. 安装`worker-loader`
`npm install worker-loader`

2. 编写`worker.js`
```js
onmessage = function (e) {
  // onmessage获取传入的初始值
  let sum = e.data;
  for (let i = 0; i < 200000; i++) {
    for (let i = 0; i < 10000; i++) {
      sum += Math.random()
    }
  }
  // 将计算的结果传递出去
  postMessage(sum);
}
```

3. 通过行内 `loader` 引入 `worker.js`
`import Worker from "worker-loader!./worker"`

4. 最终代码
```vue
<template>
    <div>
        <button @click="makeWorker">开始线程</button>
        <!--在计算时 往input输入值时 没有发生卡顿-->
        <p><input type="text"></p>
    </div>
</template>

<script>
    import Worker from "worker-loader!./worker";

    export default {
        methods: {
            makeWorker() {
                // 获取计算开始的时间
                let start = performance.now();
                // 新建一个线程
                let worker = new Worker();
                // 线程之间通过postMessage进行通信
                worker.postMessage(0);
                // 监听message事件
                worker.addEventListener("message", (e) => {
                    // 关闭线程
                    worker.terminate();
                    // 获取计算结束的时间
                    let end = performance.now();
                    // 得到总的计算时间
                    let durationTime = end - start;
                    console.log('计算结果:', e.data);
                    console.log(`代码执行了 ${durationTime} 毫秒`);
                });
            }
        },
    }
</script>
```
**计算过程中，在input框输入值，页面一直未发生卡顿**
![worker](/images/informal-essay4.png)

如果直接把这段代码直接丢到主线程中
计算过程中，页面一直处于假死状态，input框无法输入
```js
let sum = 0;
for (let i = 0; i < 200000; i++) {
    for (let i = 0; i < 10000; i++) {
      sum += Math.random()
    }
  }
```
### 开启多线程，并行计算

回到要解决的问题
执行多种运算时，给每种运算开启单独的线程，线程计算完成后要及时关闭

**多线程代码**
```vue
<template>
    <div>
        <button @click="makeWorker">开始线程</button>
        <!--在计算时 往input输入值时 没有发生卡顿-->
        <p><input type="text"></p>
    </div>
</template>

<script>
    import Worker from "worker-loader!./worker";

    export default {
        data() {
          // 模拟数据
          let arr = new Array(100000).fill(1).map(() => Math.random()* 10000);
          let weightedList = new Array(100000).fill(1).map(() => Math.random()* 10000);
          let calcList = [
              {type: 'sum', name: '总和'},
              {type: 'average', name: '算术平均'},
              {type: 'weightedAverage', name: '加权平均'},
              {type: 'max', name: '最大'},
              {type: 'middleNum', name: '中位数'},
              {type: 'min', name: '最小'},
              {type: 'variance', name: '样本方差'},
              {type: 'popVariance', name: '总体方差'},
              {type: 'stdDeviation', name: '样本标准差'},
              {type: 'popStandardDeviation', name: '总体标准差'}
          ]
          return {
              workerList: [], // 用来存储所有的线程
              calcList, // 计算类型
              arr, // 数据
              weightedList // 加权因子
          }
        },
        methods: {
            makeWorker() {
                this.calcList.forEach(item => {
                    let workerName = `worker${this.workerList.length}`;
                    let worker = new Worker();
                    let start = performance.now();
                    worker.postMessage({arr: this.arr, type: item.type, weightedList: this.weightedList});
                    worker.addEventListener("message", (e) => {
                        worker.terminate();

                        let tastName = '';
                        this.calcList.forEach(item => {
                            if(item.type === e.data.type) {
                                item.value = e.data.value;
                                tastName = item.name;
                            }
                        })

                        let end = performance.now();
                        let duration = end - start;
                        console.log(`当前任务: ${tastName}, 计算用时: ${duration} 毫秒`);
                    });
                    this.workerList.push({ [workerName]: worker });
                })
            },
            clearWorker() {
                if (this.workerList.length > 0) {
                    this.workerList.forEach((item, key) => {
                        item[`worker${key}`].terminate && item[`worker${key}`].terminate(); // 终止所有线程
                    });
                }
            }
        },
        // 页面关闭，如果还没有计算完成，要销毁对应线程
        beforeDestroy() {
            this.clearWorker();
        },
    }
</script>
```
    
[原文](https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&mid=2247515242&idx=1&sn=a76f66bf6a7b5f413f058c675fe57714&chksm=9031bf88a746369e68465078ecc0ab956409fb74614d62b4bd1878cd7669c9cb8156b9a0a7ce&scene=126&&sessionid=1662599122#rd)

## async-await

**关于异步处理问题，ES5的回调让我们陷入回调地狱轮回，后来ES6的Promise（Promise不了解？点这了解[1]）让我们脱离轮回，终于，ES7的async-await带我们走向光明。今天我们就来学习一夏 async-await，看看与Promise有何联系和区别。**

### 走进Async-await原理

1. * **async函数返回一个 Promise 对象，可以使用then方法添加回调函数**
```js
// async返回的是Promise对象？
async function testAsync() {
    return 'hello';//上篇文章Promise对象的返回值如果不是Promise，会通过Promise.resolve()转化为Promise，再进行处理
}
const result = testAsync()
console.log(result);//Promise { 'hello' }  说明async返回的是Promise对象
```
那既然async返回的是`Promise对象`，那么async后面的函数可以接.then()或者.catch()...嘛？我们试一试就知道了。
```js
// async返回的是Promise对象,并且可以接Promise的方法？
async function testAsync() {
    // await await等待还是promise对象
    return 'hello'
}
testAsync()
    .then((result)=>{
        console.log(result);
    })
    .catch((error)=>{
        console.log(error);
    })
//hello  妈耶！打印了！说明async返回的是Promise对象，并且可以接Promise的方法，并且！！！默认状态是resolved的
```
上面代码说明，`async函数内部return语句返回的值，会成为then方法回调函数的参数`

2. * **`当async函数内部抛出错误的时候，会导致返回的 Promise 对象变为reject状态`。抛出的错误对象会被.then()方法的第二个回调函数接收或者.catch()方法回调函数接收到。**
```js
// async函数内部抛出错误或者Promise状态为reject
async function testError(){
    //throw new Error('出错啦~~');
    await Promise.reject('出错了');//await前面有return和没有return效果一样
} 
testError()
    // .then(()=>{},(error)=>{console.log(error);})
    .catch(error=>{console.log(error);})
//Error: 出错啦~~
```

3. * **await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。**
```js
// await
async function getName(){
    // return '来自星星的你';
    return await '来自星星的你';//上面直接return等价于这个return
}
getName()
    .then(result=>{console.log(result);})
//来自星星的你
```

4.  **await的使用，必须要有async。**
这便是async-await的浪漫所在了：async返回的是一个Promise对象，await等待的就是这个Promise对象，所以await不能没有async（但是async可以没有await）。有没有被浪漫到？反正我是醉了。如果await没有async会怎么样？报错：
```js
// await没有async会报错
function testAwait(){
    return await '西红柿炒辣椒'
}
testAwait()
    .catch(error=>{
        console.log(error);
    })
//SyntaxError: await is only valid in async function
```

### 深入Async-await规则

1. ** async封装Promise**
```js
// async封装Promise
async function fn1() {
    return '喜羊羊与灰太狼';// //相当于return Promise.resolve('喜羊羊与灰太狼')
    const data = await fn1();//接收data值
}
fn1()//执行async函数，返回的是一个Promise对象
    .then(data => {
        console.log('content =', data)
    })

//content = 喜羊羊与灰太狼
```

2. **await相当于then**

```js
// await---.then()
async function getName(){
    const operate=Promise.resolve('白雪公主')//执行函数
    const name= await operate //await相当于Promise的then  operate.then(name=>{})
    console.log('name:',name)
}
getName();
( async function(){
    const person=await '七个小矮人' //await Promise.resolve('七个小矮人') await后面不跟Promise，也会被封装成Promise
    console.log('person:',person)//400
})();//自执行函数

//name: 白雪公主
//person: 七个小矮人
```

3. **多个await时，按时序执行**
当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。`任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行`。
```js
async function testOrder() {
    await Promise.reject('出错了')//UnhandledPromiseRejectionWarning: 出错了
    await Promise.resolve('hello world'); // 不会执行
}
testOrder();
```

4. **try…catch相当于catch**
如果希望即使前一个异步操作失败，也不要中断后面的异步操作。`可将第一个await放在try...catch结构里面`，这样不管这个异步操作是否成功，第二个await都会执行。
```js
// try...catch
!(async function () {
    const testError = Promise.reject('出错啦~~~')//rejected状态
    // const testError=throw new Error('出错啦~~~');
    try {
        const result = await testError; //await相当于then，但是reject不会触发then
        console.log('success:'+result) //不会输出，因为const result = await testError被报错，被catch捕获
    } catch (error) {
        console.error('error:'+error)//try...catch 相当于Promise的catch
    }

})()
//error:出错啦~~~
```
当await后面是Promise对象的时候，我们`也可直接在await后面直接.catch捕获`错误：
```js
async function testError() {
    await Promise.reject('出错了')
        .catch(error => console.log(error));//这里捕获错误，不会影响下一个await执行
    
    return await Promise.resolve('hello world');
}

testError()
    .then(result => console.log(result))
```

### 解析Async-await语法

```js
// 面试题
function getJSON() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log(2);
            resolve(2)
        }, 2000)
    })
}
async function testAsync() {
    await getJSON()
    console.log(3);
}
testAsync()
//2
//3
```
根据现在的知识面，我们必须知道：

>（1）await不能单独出现，其函数前面一定要有async。
>（2）await会干两件事：
>第一，将写在await后面的代码放到async创建的那个Promise里面执行。
>第二、将写在await下面的代码放到前一个创建的那个Promise对象的.then里面执行。
>3）await返回的也是Promise对象，他只是把await下面的代码放到了await返回的promise的.then里面执行。

这样的话，是不是如鱼得水了。翻译如下：
```js
function getJSON() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log(2);
            resolve(2)
        }, 2000)
    })
}
// 编译成Promise原理
function testAsync() {
    return Promise.resolve().then(() => {
        return getJSON();
    })
        .then(() => {
            console.log(3);

        })
}
testAsync()
```

### 拓展Async-await应用

1. 场景1 解决地狱回调
```js
// Promise解决方式
function doCallback(n) {
    var myPromise = new Promise(function (resolve, reject) {   
        //处理异步任务
        var flag = true;
        setTimeout(function () {
            if (flag) {
                resolve(n)
            }
            else {
                reject('失败')
            }
        },0)
    })
    return myPromise;
}

doCallback(1)
    .then((result) => { //then是成功执行的方法 返回的还是一个Promise对象
        console.log(result);//打印张三  res是执行
        return fn(2);
    })
    .then((result) => {
        console.log(result);
        return fn(3)
    })
    .then((result) => {
        console.log(result);
        return fn(4)
    })
    .then((result) => {
        console.log(result);
    })
    .catch((result) => { //catch是失败执行的方法
        console.log(result);
    })
    //好多.then,形成.then链啦
//1
//2
//3
//4
```
通过以上Promise方法，可以明显解决回调地狱“向右移”的浮夸表现，但是，`Promise是基于 then, catch 的链式调用，但也是基于回调函数`。.then链多多少少还是违背原生代码，显得也不是很优雅。作为回调终极武器，async-await更加贴近于原生代码，我们看一下吧：

```js
//封装一个返回promise的异步任务
function doCallback(str) {
    var myPromise = new Promise(function (resolve, reject) {
        var flag = true;
        setTimeout(function () {
            if (flag) {
                resolve(str)
            } else {
                reject('处理失败')
            }
        })
    })
    return myPromise;
}

//封装一个执行上述异步任务的async函数
async function testAsync() {
    var result1 = await doCallback(1);  //await直接拿到fn()返回的promise的数据，并且赋值给result
    var result2 = await doCallback(2);  //await 后面的代码，都可以看做是异步回调 callback 里的内容，都是异步的
    var result3 = await doCallback(3);
    var result4 = await doCallback(4);
    console.log(result1);
    console.log(result2);
    console.log(result3);
    console.log(result4);
}//这样是不是简洁优雅多了呢？
//执行函数
testAsync();
//1
//2
//3
//4
```

有了 async-await、promise 还有必要学习吗？通过上面async-await的解决方案可以瞧见，async / await 和 Promise 并不互斥，二者相辅相成。同时async / await 并不能改变异步的本质

## localStorage 的高阶用法

### 设计
封装之前先梳理下所需功能，并要做成什么样，采用什么样的规范，部分主要代码片段是以 `localStorage`作为示例，最后会贴出完整代码的。可以结合项目自行优化，也可以直接使用。
```js
// 区分存储类型 type
// 自定义名称前缀 prefix
// 支持设置过期时间 expire
// 支持加密可选，开发环境下未方便调试可关闭加密

// 支持数据加密 这里采用 crypto-js 加密 也可使用其他方式

// 判断是否支持 Storage isSupportStorage

// 设置 setStorage

// 获取 getStorage

// 是否存在 hasStorage

// 获取所有key getStorageKeys

// 根据索引获取key getStorageForIndex

// 获取localStorage长度 getStorageLength

// 获取全部 getAllStorage

// 删除 removeStorage

// 清空 clearStorage

//定义参数 类型 window.localStorage,window.sessionStorage,
const config = {
    type: 'localStorage', // 本地存储类型 localStorage/sessionStorage
    prefix: 'SDF_0.0.1', // 名称前缀 建议：项目名 + 项目版本
    expire: 1, //过期时间 单位：秒
    isEncrypt: true // 默认加密 为了调试方便, 开发过程中可以不加密
}
```

### 设置 setStorage
`Storage` 本身是不支持过期时间设置的，要支持设置过期时间，可以效仿 `Cookie` 的做法，`setStorage(key,value,expire)` 方法，
接收三个参数，第三个参数就是设置过期时间的，用相对时间，单位秒，要对所传参数进行类型检查。可以设置统一的过期时间，
也可以对单个值得过期时间进行单独配置。两种方式按需配置。
```js
// 设置 setStorage
export const setStorage = (key,value,expire=0) => {
    if (value === '' || value === null || value === undefined) {
        value = null;
    }

    if (isNaN(expire) || expire < 1) throw new Error("Expire must be a number");

    expire = (expire?expire:config.expire) * 60000;
    let data = {
        value: value, // 存储值
        time: Date.now(), //存值时间戳
        expire: expire // 过期时间
    };

    window[config.type].setItem(key, JSON.stringify(data));
}
```

### 获取 getStorage
首先要对 `key` 是否存在进行判断，防止获取不存在的值而报错。对获取方法进一步扩展，只要在有效期内获取 `Storage` 值，
就对过期时间进行续期，如果过期则直接删除该值。并返回 `null`
```js
export const getStorage = (key) => {
    // key 不存在判断
    if (!window[config.type].getItem(key) || JSON.stringify(window[config.type].getItem(key)) === 'null'){
        return null;
    }

    // 优化 持续使用中续期
    const storage = JSON.parse(window[config.type].getItem(key));
    console.log(storage)
    let nowTime = Date.now();
    console.log(config.expire*6000 ,(nowTime - storage.time))
    // 过期删除
    if (storage.expire && config.expire*6000 < (nowTime - storage.time)) {
        removeStorage(key);
        return null;
    } else {
        // 未过期期间被调用 则自动续期 进行保活
        setStorage(key,storage.value);
        return storage.value;
    }
}
```

**获取所有值**
```js
// 获取全部 getAllStorage
export const getAllStorage = () => {
    let len = window[config.type].length // 获取长度
    let arr = new Array() // 定义数据集
    for (let i = 0; i < len; i++) {
        // 获取key 索引从0开始
        let getKey = window[config.type].key(i)
        // 获取key对应的值
        let getVal = window[config.type].getItem(getKey)
        // 放进数组
        arr[i] = { 'key': getKey, 'val': getVal, }
    }
    return arr
}
```

**删除 removeStorage**
// 名称前自动添加前缀
const autoAddPrefix = (key) => {
    const prefix = config.prefix ? config.prefix + '_' : '';
    return  prefix + key;
}

// 删除 removeStorage
export const removeStorage = (key) => {
    window[config.type].removeItem(autoAddPrefix(key));
}

**清空 clearStorage**
```js
// 清空 clearStorage
export const clearStorage = () => {
    window[config.type].clear();
}
```

**加密、解密**

加密采用的是 `crypto-js`
```text
// 安装crypto-js
npm install crypto-js

// 引入 crypto-js 有以下两种方式
import CryptoJS from "crypto-js";
// 或者
const CryptoJS = require("crypto-js");
```
对 `crypto-js` 设置密钥和密钥偏移量,可以采用将一个私钥经 `MD5` 加密生成16位密钥获得。
```js
// 十六位十六进制数作为密钥
const SECRET_KEY = CryptoJS.enc.Utf8.parse("3333e6e143439161");
// 十六位十六进制数作为密钥偏移量
const SECRET_IV = CryptoJS.enc.Utf8.parse("e3bbe7e3ba84431a");
```
对加密方法进行封装
```js
/**
 * 加密方法
 * @param data
 * @returns {string}
 */
export function encrypt(data) {
  if (typeof data === "object") {
    try {
      data = JSON.stringify(data);
    } catch (error) {
      console.log("encrypt error:", error);
    }
  }
  const dataHex = CryptoJS.enc.Utf8.parse(data);
  const encrypted = CryptoJS.AES.encrypt(dataHex, SECRET_KEY, {
    iv: SECRET_IV,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });
  return encrypted.ciphertext.toString();
};
```
对解密方法进行封装
/**
 * 解密方法
 * @param data
 * @returns {string}
 */
export function decrypt(data) {
  const encryptedHexStr = CryptoJS.enc.Hex.parse(data);
  const str = CryptoJS.enc.Base64.stringify(encryptedHexStr);
  const decrypt = CryptoJS.AES.decrypt(str, SECRET_KEY, {
    iv: SECRET_IV,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });
  const decryptedStr = decrypt.toString(CryptoJS.enc.Utf8);
  return decryptedStr.toString();
}
在存储数据及获取数据中进行使用：

### 使用
使用的时候你可以通过 import 按需引入，也可以挂载到全局上使用，一般建议少用全局方式或全局变量，为后来接手项目继续开发维护的人，追查代码留条便捷之路！不要为了封装而封装，尽可能基于项目需求和后续的通用，以及使用上的便捷。比如获取全部存储变量，如果你项目上都未曾用到过，倒不如删减掉，留着过年也不见得有多香，不如为减小体积做点贡献！

### 完整代码
```js
/***
 * title: storage.js
 * Author: Gaby
 * Email: xxx@126.com
 * Time: 2022/6/1 17:30
 * last: 2022/6/2 17:30
 * Desc: 对存储的简单封装
 */
 
import CryptoJS from 'crypto-js';

// 十六位十六进制数作为密钥
const SECRET_KEY = CryptoJS.enc.Utf8.parse("3333e6e143439161");
// 十六位十六进制数作为密钥偏移量
const SECRET_IV = CryptoJS.enc.Utf8.parse("e3bbe7e3ba84431a");

// 类型 window.localStorage,window.sessionStorage,
const config = {
    type: 'localStorage', // 本地存储类型 sessionStorage
    prefix: 'SDF_0.0.1', // 名称前缀 建议：项目名 + 项目版本
    expire: 1, //过期时间 单位：秒
    isEncrypt: true // 默认加密 为了调试方便, 开发过程中可以不加密
};

// 判断是否支持 Storage
export const isSupportStorage = () => {
    return (typeof (Storage) !== "undefined") ? true : false;
};

// 设置 setStorage
export const setStorage = (key, value, expire = 0) => {
    if (value === '' || value === null || value === undefined) {
        value = null;
    }

    if (isNaN(expire) || expire < 0) throw new Error("Expire must be a number");

    expire = (expire ? expire : config.expire) * 1000;
    let data = {
        value: value, // 存储值
        time: Date.now(), //存值时间戳
        expire: expire // 过期时间
    };
    
    const encryptString = config.isEncrypt 
    ? encrypt(JSON.stringify(data))
    : JSON.stringify(data);
    
    window[config.type].setItem(autoAddPrefix(key), encryptString);
};

// 获取 getStorage
export const getStorage = (key) => {
    key = autoAddPrefix(key);
    // key 不存在判断
    if (!window[config.type].getItem(key) || JSON.stringify(window[config.type].getItem(key)) === 'null') {
        return null;
    }

    // 优化 持续使用中续期
    const storage = config.isEncrypt 
    ? JSON.parse(decrypt(window[config.type].getItem(key))) 
    : JSON.parse(window[config.type].getItem(key));
    
    let nowTime = Date.now();

    // 过期删除
    if (storage.expire && config.expire * 6000 < (nowTime - storage.time)) {
        removeStorage(key);
        return null;
    } else {
        // 未过期期间被调用 则自动续期 进行保活
        setStorage(autoRemovePrefix(key), storage.value);
        return storage.value;
    }
};

// 是否存在 hasStorage
export const hasStorage = (key) => {
    key = autoAddPrefix(key);
    let arr = getStorageAll().filter((item)=>{
        return item.key === key;
    });
    return arr.length ? true : false;
};

// 获取所有key
export const getStorageKeys = () => {
    let items = getStorageAll();
    let keys = [];
    for (let index = 0; index < items.length; index++) {
        keys.push(items[index].key)
    }
    return keys
};

// 根据索引获取key
export const getStorageForIndex = (index) => {
    return window[config.type].key(index)
};

// 获取localStorage长度
export const getStorageLength = () => {
    return window[config.type].length
};

// 获取全部 getAllStorage
export const getStorageAll = () => {
    let len = window[config.type].length // 获取长度
    let arr = new Array() // 定义数据集
    for (let i = 0; i < len; i++) {
        // 获取key 索引从0开始
        let getKey = window[config.type].key(i);
        // 获取key对应的值
        let getVal = window[config.type].getItem(getKey);
        // 放进数组
        arr[i] = {'key': getKey, 'val': getVal,}
    }
    return arr
};

// 删除 removeStorage
export const removeStorage = (key) => {
    window[config.type].removeItem(autoAddPrefix(key));
};

// 清空 clearStorage
export const clearStorage = () => {
    window[config.type].clear();
};

// 名称前自动添加前缀
const autoAddPrefix = (key) => {
    const prefix = config.prefix ? config.prefix + '_' : '';
    return  prefix + key;
};

// 移除已添加的前缀
const autoRemovePrefix = (key) => {
    const len = config.prefix ? config.prefix.length+1 : '';
    return key.substr(len)
    // const prefix = config.prefix ? config.prefix + '_' : '';
    // return  prefix + key;
};

/**
 * 加密方法
 * @param data
 * @returns {string}
 */
const encrypt = (data) => {
    if (typeof data === "object") {
        try {
            data = JSON.stringify(data);
        } catch (error) {
            console.log("encrypt error:", error);
        }
    }
    const dataHex = CryptoJS.enc.Utf8.parse(data);
    const encrypted = CryptoJS.AES.encrypt(dataHex, SECRET_KEY, {
        iv: SECRET_IV,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.ciphertext.toString();
};

/**
 * 解密方法
 * @param data
 * @returns {string}
 */
const decrypt = (data) => {
    const encryptedHexStr = CryptoJS.enc.Hex.parse(data);
    const str = CryptoJS.enc.Base64.stringify(encryptedHexStr);
    const decrypt = CryptoJS.AES.decrypt(str, SECRET_KEY, {
        iv: SECRET_IV,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    const decryptedStr = decrypt.toString(CryptoJS.enc.Utf8);
    return decryptedStr.toString();
};
```

## 前端性能优化到底该怎么做

**前端性能优化核心就是两点**

* **保证资源更快的 加载速度**：达到越快渲染越快，视图展现就越快
* **保证视图更快的 渲染速度/交互速度**：用户与页面交互，前提是页面要渲染出来，其次是页面需要尽早反馈，目的就是保证用户良好的体验性

>从输入 `URL` 到页面加载完成发生了什么？

在这还是要简单的总结一下核心内容：

* 进行 `DNS` 解析
* 建立 `TCP` 连接
* 客户端发送 `HTTP` 请求
* 服务端响应 `HTTP` 资源
* 浏览器获取响应内容，进行解析和渲染
***

### RAIL 模型
`Google` 为前端页面性能的评估提出了 `RAIL` 模型，核心内容如下：

* `Response` 响应
* `Animation` 动画
* `Idle` 空闲
* `Load` 加载

[RAIL 模型](/images/informal-essay5.png)

### 常规性能指标
性能指标其实有不少的内容，但在这我们指列举比较常用的几种：

* **首次绘制（`First Paint，FP`）**
    * 在渲染进程确认要渲染当前响应资源后，渲染进程会先创建一个空白页面，通常把创建空白页面的这个时间点称为 `First Paint`，简称 `FP`
    * 所谓的 `白屏时间` 其实指的就是创建这个空白页面到浏览器开始渲染非空白内容的时间，比如页面背景发生变化等

* **首次内容绘制（`First Contentful Paint，FCP`）**
    * 当用户看见一些 "内容" 元素被绘制在页面上的时间点，和白屏是不一样，它可以是 `文本` 首次绘制，或 `SVG` 首次出现，或 `Canvas` 首次绘制等，即当页面中绘制了第一个 `像素` 时，这个时间点称为 `First Content Paint`，简称 `FCP`

* **首屏时间 / 最大内容绘制（`Largest Contentful Paint, LCP`）**
    * `LCP` 是一种新的性能度量标准，`LCP` 侧重于用户体验的性能度量标准，与现有度量标准相比，更容易理解与推理，当首屏内容完全绘制完成时，这个时间点称为 `Largest Content Paint`，简称 `LCP`
    * 最大内容绘制应在 `2.5s` 内完成

* **首次输入延迟（`First Input Delay, FID`）**
    * `FID` 测量的是当用户第一次在页面上交互的时候（**点击链接**、**点击按钮** 或 **自定义基于 js 的事件**），到浏览器实际开始处理这个事件的时间
    * 首次输入延迟应在 **100ms** 内完成

* **累积布局偏移（`Cumulative Layout Shift, CLS`)**
    * `CLS` 是为了测量 视觉稳定性，以便提供良好的用户体验
    * 累积布局偏移应保持在 `0.1` 或更少

* **首字节达到时间（`Time to First Byte，TTFB`）**
    * 指的是浏览器开始收到服务器响应数据的时间（**后台处理时间** + **重定向时间**），是反映服务端响应速度的重要指标
    * **`TTFB` 时间如果超过 `500ms`，用户在打开网页的时就会感觉到明显的等待**
    
通过上述内容了解了性能指标的相关内容和一些阀值，那么接下来的问题是我们怎么获取一个网站的具体性能指标数据呢？

为了方便还是得使用工具或者说是 `API`，当然可以 **自定义页面性能指标** 的计算方式，比如有些就是通过计算当前页面 `DOM` 的 **总节点数** 和 **嵌套层级** 来计算一个网站的分数等，这里就不再额外介绍。
***

### Performance 面板（Google）

## 打印时， 这个单分到下一页，
主要看：initPrintDiv这个方法
思路: 是知道A4纸大小。然后循环div中的元素一个一个高的的累加，如果达到A4纸大小，将下一个元素加上class。最后控制class给个margin
```vue
<template>
  <div class="order-info">
    <div class="data table-border-color">
      <div class="data-value table-border-color image-uploader title">
        {{ orderName }}
      </div>
      <template v-for="(item, index) in orderData">
        <div
          :class="
            'data-item table-border-color image-uploader ' +
            (!item.value ? ' no-uploader' : '')
          "
          v-if="item.type === 'image-uploader'"
          :key="item.uKey + index"
        >
          <div class="data-title background-color-2" :title="item.label">
            {{ item.label }}
          </div>
          <div class="data-value table-border-color" :title="item.value">
            <template v-if="item.type === 'image-uploader'">
              <img
                v-for="(file, fileIndex) in getFileList(item.value)"
                :key="`form_data_${item}_${fileIndex}`"
                :src="file"
                class="form-image"
                @click="showBigImg(getFileList(item.value))"
              />
            </template>
          </div>
        </div>
        <div
          :class="'data-item table-border-color location '"
          v-else-if="item.type === 'location-and-position'"
          :key="item.uKey + index"
        >
          <div class="data-title background-color-2" :title="item.label">
            {{ item.label }}
          </div>
          <div class="data-value table-border-color" :title="item.value">
            {{ item.value.address || "" }}
          </div>
        </div>
        <div
          :class="'data-item table-border-color file-list '"
          v-else-if="item.type === 'upload-file'"
          :key="item.uKey + index"
        >
          <div class="data-title background-color-2" :title="item.label">
            {{ item.label }}
          </div>
          <div class="data-value table-border-color" title="file-list">
            <div class="file-name" v-for="val in item.value" :key="val.id">
              {{ val.name }}
            </div>
          </div>
        </div>
        <div
          class="data-item table-border-color"
          :class="item.type === 'textarea' ? 'textarea' : ''"
          v-else
          :key="item.uKey + index"
        >
          <div class="data-title background-color-2" :title="item.label">
            {{ item.label }}
          </div>
          <div class="data-value table-border-color" :title="item.value">
            {{ item.value }}
          </div>
        </div>
      </template>
    </div>
  </div>
</template>

<script>
import { discData } from "@/utils/getDicts.js";
import { dictionaryPageList } from "@/api/basicData.js";
import "viewerjs/dist/viewer.css";
// import Viewer from 'v-viewer'
// import Vue from 'vue'
// Vue.use(Viewer)
export default {
  props: {
    data: {
      type: Object,
      default: () => {},
    },
    subType: {
      type: Array,
      default: () => [],
    },
    isPrint: Boolean,
  },
  data() {
    return {
      orderName: "",
      orderData: [],
    };
  },
  methods: {
    initPrintDiv() {
      let arr = document.querySelectorAll("#pdfDom .data-item");
      // 第一页纸有所不同 有学生姓名以及二维码 所以第一次需要计算这个高度
      let newNum = document.querySelector("#pdfDom .data-value").offsetHeight;
      // 循环页面上的所有答题框
      var flag = 0;
      var addFlag = 0; //15
      for (let i = 0; i < arr.length; i++) {
        // 加上间距 严谨点可以再加上边框
        var classList = arr[i].classList;
        // console.log(i, arr[i].offsetHeight, JSON.stringify(classList));
        var extreaHeight = 0;
        if (
          !classList.contains("textarea") &&
          !classList.contains("image-uploader") &&
          !classList.contains("file-list")
        ) {
          // 处理一行两列情况
          flag++;
        } else {
          if (flag === 1) {
            // 代表上方还有一行半列占位
            extreaHeight = arr[i - 1].offsetHeight;
            arr[i - 1].classList.add("single-column");
            console.log(
              i - 1,
              arr[i - 1].offsetHeight,
              JSON.stringify(arr[i - 1].classList)
            );
          }
          flag = 2;
        }

        var currentHeight = arr[i].offsetHeight;
        if (
          classList.contains("image-uploader") &&
          !classList.contains("no-uploader")
        ) {
          currentHeight = 160;
        }

        currentHeight += extreaHeight;

        // if (flag === 2 && (newNum + currentHeight + addFlag) / 750 >= 1.4) {
        if (flag === 2 && newNum + currentHeight + addFlag >= 22 * 51) {
          // console.log(
          //   "a4",
          //   newNum,
          //   newNum + currentHeight + addFlag,
          //   arr[i].offsetWidth
          // );
          // 如果答题框的比例 大于或者等于一张a4纸的比例（1.3）
          // 那么就在上一个答题框上面加上类名 dataTest
          // 类名样式 dataTest: page-break-after:always; 强制让这个元素跳到下一页
          // 且初始化 newNum
          arr[i - 1].classList.add("dataTest");
          var currentMarginValue = arr[i].offsetHeight;
          if (
            arr[i - 1].classList.contains("image-uploader") &&
            !arr[i - 1].classList.contains("no-uploader")
          ) {
            currentMarginValue = 160;
          }
          // arr[i - 1].setAttribute(
          //   "style",
          //   `margin-top:${currentMarginValue}px`
          // );
          newNum = currentHeight + 120;
          flag = 0;
        } else {
          // 如果没有超过正常a4的比例就继续累加下一个答题框的高度和间距
          if (flag === 2) {
            // 处理一行两列情况
            newNum += currentHeight + addFlag;
            flag = 0;
            // console.log(i, arr[i].offsetHeight, JSON.stringify(classList));
          }
        }
      }
    },
    /**
     * 处理工单数据
     */
    handleData() {
      const disabledTypes = ["group", "next-info", "handler"];
      // 可展示数据
      let orderDataMap = {};
      console.log("eric", this.data);

      for (let i = 0; i < this.data.diyAttrs.length; i++) {
        let item = JSON.parse(JSON.stringify(this.data.diyAttrs[i]));
        // if (this.data.linkName === '结束流程' || this.data.formOpt[item.uKey] !== 'vif') {
        if (item.label === "工单类型") {
          this.orderName = this.data.subTypeName;
          this.$emit("updateOrderName", this.orderName);
          continue;
        }
        if (item.label === "承办处") {
          item.value = this.undertakerMap[item.value].dictLabel;
        }
        if (item.label === "是否伤人") {
          item.value = item.value === 1 ? "是" : "否";
        }

        if (["dictionary", "radio"].includes(item.type)) {
          if (
            this.data.form &&
            this.data.form.formDesc &&
            this.data.form.formDesc[item.uKey] &&
            this.data.form.formDesc[item.uKey].isOptions
          ) {
            var itemOption = this.data.form.formDesc[item.uKey].options;
            if (item.type === "dictionary" && itemOption.length > 0) {
              var dicParams = {
                condition: {
                  dictTypeId: itemOption[0],
                },
                pageNum: 1,
                pageSize: 10000,
              };
              dictionaryPageList(dicParams).then((res) => {
                var dicResultItem = (res.data || []).find(
                  (f) => f.id === item.value
                );

                console.log("res.data)", res.data, dicResultItem);
                if (dicResultItem) {
                  item.value = dicResultItem.dictLabel;
                  console.log("item.value", item.value);
                }
              });
            } else {
              var dicItem = (itemOption || []).find(
                (f) => f.value === item.value
              );
              if (dicItem) {
                item.value = dicItem.text;
              }
            }
          }
        }

        if (disabledTypes.indexOf(item.type) === -1) {
          orderDataMap[item.uKey] = item;
        }
        // }
      }
      let result = [];
      this.data.form.order.forEach((item) => {
        if (orderDataMap[item]) {
          result.push(orderDataMap[item]);
        }
      });
      result.unshift({ label: "工单编号", value: this.data.number });
      this.orderData = result;
    },
    /**
     * 保存为PDF
     */
    saveAsPDF() {},
    /**
     * 确认打印
     */
    print() {},
    getFileList(data) {
      if (!data) {
        return [];
      }
      let result = [];
      let baseUrl = this.$Api().MediaInfoController.get_preview.url.replace(
        "{mediaInfoId}",
        ""
      );
      if (typeof data === "string") {
        result = [baseUrl + data];
      } else {
        result = data.map((v) => {
          if (v.fileId) {
            return baseUrl + v.fileId;
          }
        });
      }
      return result;
    },
    showBigImg(urls) {
      window.parent.frameEvent({
        type: "imagePerview",
        urls,
      });
    },
  },
  computed: {
    subTypeMap() {
      let map = {};
      this.subType.forEach((item) => {
        map[item.value] = item;
      });
      return map;
    },
    undertakerMap() {
      console.log(discData.undertaker);
      let map = {};
      discData.undertaker.forEach((item) => {
        map[item.id] = item;
      });
      return map;
    },
  },
  created() {
    if (this.isPrint) {
      this.$nextTick(() => {
        this.initPrintDiv();
      });
    }
  },
  mounted() {
    this.handleData();
  },
};
</script>

<style lang="scss" scoped>
.order-info {
  .data {
    display: flex;
    flex-wrap: wrap;
    // margin-top: 2 * $margin-size;
    position: relative;
    // border:1px solid;
    &::before {
      content: " ";
      position: absolute;
      width: calc(100% - 1px);
      height: calc(100% - 1px);
      // background: #f00;
      // z-index: -1;
      // border: 1px solid;
      border-color: inherit;
    }
    .title {
      line-height: 49px;
      text-align: center;
      font-size: 18px;
    }
    .data-item {
      width: calc(50% + 1px);
      display: flex;
      border: 1px solid;
      margin-right: -1px;
      margin-bottom: -1px;
      // margin-left: -1px;
      // margin-top: -1px;
      // height: 48px;
      // line-height: 48px;
      position: relative;

      .data-title {
        width: 144px;
        height: 100%;
        padding: 15px 2 * $margin-size;
        // white-space: nowrap;
        // overflow: hidden;
        // text-overflow: ellipsis;
        flex-shrink: 0;
      }
      .data-value {
        border-left: 1px solid;
        width: 100%;
        height: 100%;
        padding: 15px 2 * $margin-size;
        // white-space: nowrap;
        // overflow: hidden;
        // text-overflow: ellipsis;
      }
    }
    // 安装地址
    $width100: calc(100% + 2px);
    .data-item.textarea,
    .data-item.single-column {
      width: $width100;
    }
    // 图片
    .image-uploader {
      width: $width100;
      // padding: $margin-size;
      height: auto;
      .data-value {
        display: flex;
        flex-wrap: wrap;
        .form-image {
          max-height: 140px;
          margin: $margin-size;
        }
      }
    }
    .file-list {
      width: $width100;
      .data-value {
        display: flex;
        flex-wrap: wrap;
      }
      .file-name {
        margin: 4px 10px;
        flex-shrink: 0;
      }
    }
    .location {
      width: $width100;
    }
    .upload-file {
      width: $width100;
      height: auto;
      .data-value {
        white-space: inherit;
        line-height: 24px;
      }
    }
  }
}
</style>

```

### v-print-nb
1. 安装v-print-nb插件
```text
npm install vue-print-nb --save
```
2. 数据加载
```js
/*打印预览*/
    const printPdf = function(mergeEbeln) => {
      this.signal = false;
      this.dylist = [];
      getPrintList({mergeEbeln:mergeEbeln}).then(response => {
        /*分页*/
        if (response.data.listdetail.length > 0) {
          response.data.text = "";
          this.inServForm = response.data
          //使用 .replace(/[\t]/g,''); 替换\t转义符，防止页面变形
          this.inServForm.modeldes = this.inServForm.modeldes.replace(/[\t]/g,'');
          this.dylist = this.doSplice(response.data.listdetail, 14)
          /*判断最后的签名信息是否单独起一页*/
          if (this.dylist[this.dylist.length - 1].length > 10) {
            this.signal = true
          }
          this.printShow = true
        }
      })
    }
```
3. 排版
```js
const changeFormat = function()=>{/*排版*/
      var declareHeight = this.$refs.declare.clientHeight;/*合同文本像素高度*/
      var changeFormatDIVHeight = this.$refs.changeFormatDIV.clientHeight;/*2cm*/
      var decalreReallyHeight = Math.floor((declareHeight/changeFormatDIVHeight)*2);/*合同文本厘米高度*/
      var leftHeight = 29.7-1.5-decalreReallyHeight;/*剩余部分高度*/
      var colunmNum = Math.floor(leftHeight/2);/*能放下几行*/
      this.dylist=[];
      /*分页*/
      var tempList = this.inServForm.listdetail;
      if (tempList.length > colunmNum) {
        this.dylist = this.doSpliceFormat(tempList,14,colunmNum);
      }else {
        this.dylist.push(tempList);
      }
      /*判断最后的签名信息是否单独起一页*/
      if(this.dylist.length>1){
        if (this.dylist[this.dylist.length - 1].length > 10) {
          this.signal = true;
        } else {
          this.signal = false;
        }
      }else if (this.dylist.length==1) {
        if (colunmNum - this.dylist[0].length<3){
          this.signal = true;
        } else {
          this.signal = false;
        }
      }
      this.printShow = true
      this.$refs.printHandle.$el.click();
    }
```
4. 打印预览
```vue
<!--打印页面-->
    <!--startprint-->
    <el-dialog title="打印预览" :visible.sync="printShow" width="22cm" append-to-body>
      <el-form :model="inServForm" ref="inServForm" size="small">
        <el-form-item>
          <div  ref="changeFormatDIV" style="height: 2cm">
            <el-button
              v-print="'#printPage'"
              type="primary"
              icon="el-icon-printer"
              ref="printHandle"
            >
            </el-button>
            <el-button
              type="danger"
              plain
              icon="el-icon-printer"
              @click="changeFormat"
              style="margin-left: -50px;width: 2cm"
            >打印
            </el-button>
          </div>
        </el-form-item>
        <div id="printPage" ref="printPage" style="width: 21cm;page-break-before:always;margin: 0cm 1cm 1cm 0.5cm;">
          <template>
           <!-- el-table 或其他待打印内容 -->
          </template>
        </div>
        <el-form-item style="text-align: right">
          <el-button
            type="danger"
            plain
            icon="el-icon-printer"
            @click="changeFormat"
            style="width: 2cm"
          >打印
          </el-button>
          <el-button
            type="warning"
            plain
            icon="el-icon-d-arrow-left"
            @click="cancelPrint"
          >返回
          </el-button>
        </el-form-item>
      </el-form>
    </el-dialog>
    <!--endprint-->
```
[VUE如何利用vue-print-nb实现打印功能详解](https://www.jb51.net/article/245567.htm)

## 抓包技能

### 前言
时隔 3 年，重新接触了移动端 h5 页面开发，上一次还是大四实习。这一次是 hybrid 开发，涉及到 h5 页面与原生 app 的交互，h5 页面需要与原生打通登录态，以及调用原生app 的接口，比如调用原生相机进行二维码扫描。跟微信小程序开发不同，本地开发时微信有提供微信开发者工具，可以本地模拟调用而我这边需要每次都打包静态文件，上传服务器才能调试，非常麻烦。

能不能在原生 app 加载线上 h5 时，跑本地的代码呢？答案是可以的，通过抓包工具比如 whistle 就可以做到拦截线上页面请求数据，再响应本地代码，本文主要讲述抓包的原理和抓包工具 whistle 使用。

### 抓包的原理
*什么是抓包*
抓包就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，通过抓包可以：

* 分析网络问题
* 业务分析
* 分析网络信息流通量
* 网络大数据金融风险控制
* 探测企图入侵网络的攻击
* 探测由内部和外部的用户滥用网络资源
* 探测网络入侵后的影响
* 监测链接互联网宽频流量
* 监测网络使用流量（包括内部用户，外部用户和系统）
* 监测互联网和用户电脑的安全状态
* 渗透与欺骗
* ...

回顾下计算机网络知识，数据在网络上是以很小的帧的单位传输的，帧通过特定的称为网络驱动程序的程序进行成型，然后通过网卡发送到网线上，通过网线到达目的机器，在目的机器的一端执行相反的过程。

接收端机器的以太网捕获到这些帧，并告诉操作系统帧已到达，然后对其进行存储。在这个传输和接收的过程，就可以使用抓包工具（Sniffers）进行抓包，作为前端开发者，通常是抓取应用层的 HTTP/HTTPS 的包。

回顾下计算机网络知识，数据在网络上是以很小的帧的单位传输的，帧通过特定的称为网络驱动程序的程序进行成型，然后通过网卡发送到网线上，通过网线到达目的机器，在目的机器的一端执行相反的过程。

接收端机器的以太网捕获到这些帧，并告诉操作系统帧已到达，然后对其进行存储。在这个传输和接收的过程，就可以使用抓包工具（Sniffers）进行抓包，作为前端开发者，通常是抓取应用层的 HTTP/HTTPS 的包。

*HTTP/HTTPS 抓包原理*

HTTP/HTTPS 是应用层使用的通信协议，常见的应用层体系结构是客户端-服务器体系。

对运行在不同端系统上的客户端程序和服务端程序是如何互相通信的么？实际上，在操作系统上的术语中，进行通信的实际上是进程而不是程序，一个进程可以被认为是运行在端系统中的一个程序。

在 web 应用程序中，一个客户浏览器进程与一台服务器进程进行会话交换报文。

浏览器进程需要知道接收进程的主机地址，以及定义在目的主机中的接收进程的标识符，也就是目的端口。

多数应用程序由通信进程对组成，每对中的两个进程互相发送报文。进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文。

进程可以类比一座房子，而它的套接字可以是它的门，套接字是应用层与运输层之间的端口。


**HTTP 抓包原理**
在 http 标准中，没有对通信端身份验证的标准。对于服务器来说，它接收的 HTTP 请求报文只要格式符合规范，就发送响应报文。

对于客户端来说也是如此，它无法校验服务器的身份，比如它连接的 `http://www.jecyu.com` 的主机，但由于中间节点的存在，最终连接的可能是 `http://www.jerry.com` 的主机。

因此，对于 HTTP 抓包，无需做过多的处理，只需要让中间人负责转发客户端和服务端的数据包。

**HTTPS 抓包原理**
HTTP 是明文传输，容易受到中间人攻击，不安全。

HTTPS 语义仍然是 HTTP，只不过是在 HTTP 协议栈中 http 与 tcp 之间插入安全层 SSL/TSL。

安全层采用对称加密的方式加密传输数据和非对称加密的方式来传输对称密钥，解决 http 数据没有加密、无法验证身份、数据容易纂改三个核心问题。

>HTTP + 加密 + 认证 + 完整性保护 = HTTPS

**其中验证身份问题是通过验证服务器的证书来实现的，证书是第三方组织（CA 证书签发机构）使用数字签名技术管理的**，包括创建证书、存储证书、更新证书、撤销证书。

浏览器连接至一个 HTTPS 网站，服务器发送的不仅仅只是服务器实体证书，而是一个证书链，但不包含根证书，根证书会被内嵌在 Windows, Linux, macOS, Android, iOS 这些操作系统里。

其中校验证书分为两步，证书的签发者校验和服务器实体证书校验
1. 证书链校验：
    
    * 1.1 浏览器从服务器实体证书的上一级证书（比如 B 证书）获取公钥，用来校验服务器实体证书的签名（签名是通过 CA 机构的私钥签名的），校验成功则继续，否则证书校验失败。

    * 1.2 浏览器从 B 证书的上一级证书（比如 C 证书）获取公钥，用来校验 B 证书的签名，

校验成功则继续，否则证书校验失败。
    * 1.3 浏览器迭代校验每张证书的签名，最后会找到自签名的根证书（签发者和使用者是同一个人），由于浏览器已经集成了根证书，可以充分信任根证书的公钥，完成最后的签名。

2. 服务器实体证书校验：访问的域名信息是否与证书一致、日期、证书扩展校验等。
了解完证书校验后，我们来看看具体的 https 通信流程：
    * 首先是 **tcp** 的三次握手建立连接
    * 接着是非对称加密的握手过程
    * **client** 发送随机数 **random1** + 支持的加密算法集合
    * **server** 收到信息，返回选择的一个加密算法+ 证书 （包含S_公钥） + **random2**
    * **client** 验证证书有效性，并用 **random1 + random2** 生成 **pre-master-secure**，通过服务端公钥加密发送给 **server**
    * **server** 收到 **pre-master-secure**，根据约定的算法使用S_私钥对 **pre-master-secure** 解密，
    * 然后用加密算法生成 **master-secure**（对称加密的密钥），然后发送给 **client**
    * **client** 收到生成的 **master-secure**，对称加密密钥传输完毕
    * 最后，就可以使用 **master-secure** 进行真正的数据对称加密传输。

**中间人想要抓包，需在 HTTPS 加密通信之前：**
1. 截取客户端发送的包含证书的报文，伪装成服务端，把自己的证书发给客户端，然后拿到【客户端返回的包含对称加密通信密钥的报文】，生成中间人与客户端对称加密的密钥。

2. 同样伪装成客户端，以服务端自己的非对称公钥加密【客户端返回的包含对称加密通信密钥的报文】发给服务端，获得服务端生成的对称加密密钥。

3. 这样一来，加密通信建立完成，而中间人拿到了通信的数据密钥，可以查看、修改 **HTTPS** 的通信报文。

4. 这里客户端与中间人通信、中间人与服务端通信，都是正常建立了 **HTTPS** 加密连接的。

其中很重要的一步是**浏览器的根证书校验**，CA 机构不可能随便给一个中间人签发不属于它的域名证书，也就不在客户端的操作系统上了，因此只能把**中间人的根证书，导入到客户端的操作系统**了，以此完成建立加密通信时对中间人证书的验证。

### 电脑如何抓手机的包
要想通过电脑端获取手机 Web 应用的数据包，根据前面所学，就需要中间人策略。

PC 端建立一个服务器中间人进程，伪装为 web 应用的目标服务器。手机端 web 应用发送的请求数据先经过中间人，中间人进行拦截处理再发送给目标服务器。反过来，目标服务器发送的数据包先通过中间人，再由中间人响应给浏览器客户端。

这里要注意的是，无论是个人电脑PC，还是移动端手机，都需要接入互联网网络，可以相互找到对方才能建立通信。

一般对开发来说，个人电脑本地起的服务器进程，在公网上是访问不到的。一般是无线局域网，个人电脑与手机端连接同一个路由器发出的 Wi-Fi，就可以相互通信。

具体步骤：
在 PC 电脑本地起一个服务器进程，监听一个端口比如 8899

在手机上连接同一个局域网，配置网络代理，指向 PC 端的 IP 地址和 8899 端口

这样一来，手机上所有的网络通信都会被先转发到 PC 端的 8899 端口，就可以对数据包进行分析处理

拿访问 youtuBe 来说，比如电脑已经使用【服务器软件】成功访问，此时只要手机配置代理指向电脑 ip 地址和指定端口，手机就可以同样访问 youtuBe了。

### 抓包工具 whistle

**whistle 是什么**
Whistle 是基于 Node 实现的跨平台抓包免费调试工具，其主要特点：

1. 完全跨平台：支持 Mac、Windows 等桌面系统，且支持服务端等命令行系统

2. 功能强大：
    * 支持作为 HTTP、HTTPS、SOCKS 代理及反向代理
    * 支持抓包及修改 HTTP、HTTPS、HTTP2、WebSocket、TCP 请求
    * 支持重放及构造 HTTP、HTTPS、HTTP2、WebSocket、TCP 请求
    * 支持设置上游代理、PAC 脚本、Hosts、延迟（限速）请求响应等
    * 支持查看远程页面的 console 日志及 DOM 节点
    * 支持用 Node 开发插件扩展功能，也可以作为独立 npm 包引用
3. 操作简单
    * 直接通过浏览器查看抓包、修改请求
    * 所有修改操作都可以通过配置方式实现（类似系统 Hosts），并支持分组管理
    * 项目可以自带代理规则并一键配置到本地 Whistle 代理，也可以通过定制插件简化操作

**如何快速使用 whistle**
1. 先安装 node，建议用 nvm 管理
2. 全局安装 whistle

```text
npm i -g whistle & w2 start
```

安装后，可以在电脑上设置全局代理，代理的端口为 8899.
```text
w2 proxy // 设置全局代理

w2 proxy off // 关闭全局代理
```
就可以通过浏览器访问 http://127.0.0.1:8899/ 查看抓包、修改请求等。

如果你不想使用全局代理，就可以安装 **SwitchyOmega** 插件，按需对某些网站设置 **whistle** 代理。

1. 选择 Whistle 代理
2. 设置 Whistle 代理

[原文地址](https://mp.weixin.qq.com/s/9hkf4-s2FNlAKD8MfwfJsQ)

## w文件上传工具 sftp
**putty**
生产密钥
**winscp**
下载 登录就可以远程修改文件
[官网](https://winscp.net/eng/index.php)

## 从 微信 JS-SDK 认识 JSBridge
[原文地址](https://mp.weixin.qq.com/s/z0m4-m135I_xl78mqcwBGw)

**Node 架构**
核心内容如下：

* 顶层 `Node Api`
    * 提供 `http` 模块、流模块、fs文件模块等等，可以通过 `JavaScript` 直接调用
* 中间层 `Node Bindings`
    * 主要是使 `JavaScript` 和 C/C++ 进行通信，原因是 `JavaScript` 无法直接调用 `C/C++` 的库（`libuv`），需要一个中间的桥梁，`node` 中提供了很多 `binding`，这些称为 `Node bindings`
* 底层 `V8 + libuv`
    * v8 负责解释、执行顶层的 `JavaScript` 代码
    * `libuv` 负责提供 `I/O` 相关的操作，其主要语言是 `C/C++` 语言，其目的就是实现一个 跨平台（如 `Windows`、`Linux` 等）的异步 `I/O` 库，它直接与操作系统进行交互
这里不难发现 `Node Bindings` 就有点类似 `JSBridge` 的功能，所以 `JSBridge` 本身是一个很简单的东西，其更多的是 一种形式、一种思想。

### 为什么叫 JSBridge？
Stack Overflow 联合创始人 Jeff Atwood 在 2007 年的博客`《The Principle of Least Power》`中认为 “任何可以使用 `JavaScript` 来编写的应用，并最终也会由 `JavaScript` 编写”，后来 `JavaScript` 的发展确实非常惊人，现在我们可以基于 JavaScript 来做各种事情，比如 网页、APP、小程序、后端等，并且各种相关的生态越来越丰富。

作为 Web 技术逻辑核心的 JavaScript 自然而然就需要承担与 其他技术 进行『桥接』的职责，而且任何一个 移动操作系统 中都会包含 运行 JavaScript 的容器环境，例如 WebView、JSCore 等，这就意味着 运行 JavaScript 不用像运行其他语言时需要额外添加相应的运行环境。

:::warning
`JSBridge` 应用在国内真正流行起来则是因为 `微信` 的出现，当时微信的一个主要功能就是可以在网页中通过 `JSBridge` 来实现 内容分享。
:::

`JSBridge` 作为 `JavaScript` 与 `Native` 之间的一个 桥梁，表面上看是允许 `JavaScript` 调用 `Native` 的功能，但其核心是建立 `Native` 和 非 `Native` 间消息 双向通信 通道。
双向通信的通道：

*`JavaScript` 向 `Native` 发送消息:
    * 调用 `Native` 功能
    * 通知 `Native` 当前 `JavaScript` 的相关状态等
* `Native` 向 `JavaScript` 发送消息:
    * 回溯调用结果
    * 消息推送
    * 通知 `JavaScript` 当前 `Native` 的状态等

**JSBridge 是如何实现的？**
JavaScript 的运行需要 JS 引擎的支持，包括 Chrome V8、Firefox SpiderMonkey、Safari JavaScriptCore 等，总之 JavaScript 运行环境 是和 原生运行环境 是天然隔离的，因此，在 JSBridge 的设计中我们可以把它 类比 成 JSONP 的流程：
    * 客户端通过 JavaScript 定义一个回调函数，如: function callback(res) {...}，并把这个回调函数的名称以参数的形式发送给服务端
    * 服务端获取到 callback 并携带对应的返回数据，以 JS 脚本形式返回给客户端
    * 客户端接收并执行对应的 JS 脚本即可
* JSBridge 实现 JavaScript 调用的方式有两种，如下：
    * JavaScript 调用 Native
    * Native 调用 JavaScript
在开始分析具体内容之前，还是有必要了解一下前置知识 WebView。

**WebView 是什么？WebView 是什么？**
WebView 是 原生系统 用于 移动端 APP 嵌入 Web 的技术，方式是内置了一款高性能 webkit 内核浏览器，一般会在 SDK 中封装为一个 WebView 组件。

WebView 具有一般 View 的属性和设置外，还对 url 进行请求、页面加载、渲染、页面交互进行增强处理，提供更强大的功能。

WebView 的优势 在于当需要 更新页面布局 或 业务逻辑发生变更 时，能够更便捷的提供 APP 更新：

对于 WebView 而言只需要修改前端部分的 Html、Css、JavaScript 等，通知用户端进行刷新即可
对于 Native 而言需要修改前端内容后，再进行打包升级，重新发布，通知用户下载更新，安装后才可以使用最新的内容

**JavaScript 调用 Native — 实现方案一**

## 一文教你实现PDF 预览和下载
[原文地址](https://mp.weixin.qq.com/s/vQYWEmcBbCvGTe8Gcsfc1Q)
**基本要求：**

*支持 `pdf 文件` 内容的 完整预览
*`多页 pdf 文件` 支持 `分页查看`
*`PC 端` 和 `移动端` 都需支持 **下载** 和 **预览**

***

**产品要求：**

* `PC 端` 的预览要支持在 **当前页** 进行预览
* `pdf 文件` 预览时的字体要 和 实际文件的 **字体保证一致性**

### 目前实现 PDF 预览的几种常用方式：

* 借助各种类库，基于代码实现预览，如基于 **`pdfjs-dist`** 的包
* 直接基于各个浏览器内置的 PDF 预览插件，如 <iframe src="xxx">、<embed src="xxx" >
* 服务端将 PDF 文件转换成图片

**<embed> 标签**
`<embed>` 元素 将外部内容嵌入文档中的指定位置，此内容由 外部应用程序 或 其他交互式内容源（如 浏览器插件）提供。

说简单点，就是使用 `<embed>` 来展示的资源是完全交由它所在的环境提供的展示功能，即如果当前的应用环境支持这个资源的展示那么就可以正常展示，如果不支持那就无法展示。

使用起来也是非常简单：
```html
<embed
 type="application/pdf"
 :src="pdfUrl"
 width="800"
 height="600" />
```
>>> 多数现代浏览器已经弃用并取消了对浏览器插件的支持，现在已经不建议使用 `<embed> `标签，但可以使用 `<img>`、`<iframe>`、`<video>`、`<audio>` 等标签代替。

**<iframe> 标签**
基于 <iframe> 的方式和以上差不多，整体效果也一致，这里这就不在额外展示：
```html
<iframe
 :src="pdfUrl"
 width="800"
 height="600" />
```

**vue3-pdfjs 实现预览**

**pdf.js** 几个明显的可吐槽的点：

* 包名称不统一，`npm` 上的包名叫 `pdfjs-dist`，然而在 `Readme` 中自己又称其为 `pdf.js`
* 没有清晰的文档作为指引，只能通过其仓库中的 `examples` 目录的内容作为参考
* 官方示例不够友好，例如没有提供 `vue/react` 等相关的示例
* 直接使用需要引入很多文档没有指明的内容
* 有时展示的 `pdf` 内容文字模糊或缺少部分等

因此，既然已经有基于 `vue/react` 封装好的包，这里就直接用来作为演示。

安装和使用过程可参考 **`vue3-pdfjs`** ，具体 Vue3 示例代码如下：
```js
<script setup lang="ts">
import { onMounted, ref } from 'vue'
import { VuePdf, createLoadingTask } from 'vue3-pdfjs/esm'
import type { VuePdfPropsType } from 'vue3-pdfjs/components/vue-pdf/vue-pdf-props' // Prop type definitions can also be imported
import type { PDFDocumentProxy } from 'pdfjs-dist/types/src/display/api'
import pdfUrl from './assets/You-Dont-Know-JS.pdf'

const pdfSrc = ref<VuePdfPropsType['src']>(pdfUrl)
const numOfPages = ref(0)

onMounted(() => {
  const loadingTask = createLoadingTask(pdfSrc.value)
  loadingTask.promise.then((pdf: PDFDocumentProxy) => {
    numOfPages.value = pdf.numPages
  })
})
</script>

<template>
  <VuePdf v-for="page in numOfPages" :key="page" :src="pdfSrc" :page="page" />
</template>

<style>
@import '@/assets/base.css';
</style>
```

## 手把手教你用 node 写一个爬虫，超简单！

### 准备工作
***
1. 通过指令`npm init`初始化文件夹，会获得`package.json`项目说明书。

2. 爬虫必备工具：`cheerio`；通过在终端输入`npm i cheerio`，即可将文件装到项目里。`cheerio` 是 `jquery` 核心功能的一个快速灵活而又简洁的实现，主要是为了用在服务器端需要对 `DOM` 进行操作的地方。大家可以简单的理解为用来解析 `html` 非常方便的工具。

### 开始
1. 用`https模块`(`node`直接提供给我们的)获取网站地址，通过`get`方法读取网站地址上的数据。
```js
const https = require('https')
https.get('https://movie.douban.com/top250', function (res) {
 let html = ''
 res.on('data', function (chunk) {
 //console.log(chunk + '');
 //得到数据流，通过字符串拼接得到html结构
 html += chunk
 })
 // 这样会读取到整个页面的html结构。
```

2. 通过 `res.on('end', function () {})`，保证读取完了才会去做操作。

3. 引入 `cheerio`
`const cheerio = require('cheerio')`

4. 获取`html`中的数据
```js
const $ = cheerio.load(html)
 $('li .item').each(function () {
 const title = $('.title', this).text()
 const star = $('.info .bd .rating_num', this).text()
 const pic = $('.pic img', this).attr('src')
 })
 // 这里需要注意的是我们可以去页面上看我们需要拿到哪个类名里面的内容，通过$符号可以拿到内容。
```

5. 创建一个空数组，把数据以对象的形式存放在数组中
```js
let allFiles = []
 allFiles.push({
 title: title,
 star: star,
 pic: pic
 })
```
我们可以通过`console.log(allFiles)`来检查是否打印出来了我们需要的结果。

6. 将数据写入文件，引用 `node` 官方提供的模块 `fs`
   `const fs = require('fs')`

7. 创建文件夹`files.json`，向其中写入数据
```js
fs.writeFile('./files.json', JSON.stringify(allFiles), function (err, data) {
 if (err) {
 throw err
 }
 console.log('文件保存成功');
 })
```
到这之后，我们可以看到在当前文件夹下自动创建了文件`files.json`，里面已经有了我们想要的数据。

### 完整代码
```js
//引入模块
const https = require('https')
const cheerio = require('cheerio')
const fs = require('fs')
//获取页面的html结构
https.get('https://movie.douban.com/top250', function (res) {
 let html = ''
 res.on('data', function (chunk) {
 //console.log(chunk + '');
 html += chunk
 })
 res.on('end', function () {
 // 获取html中的数据
 const $ = cheerio.load(html)
 let allFiles = []
 //拿到每一个item中我们需要的数据
 $('li .item').each(function () {
 const title = $('.title', this).text()
 const star = $('.info .bd .rating_num', this).text()
 const pic = $('.pic img', this).attr('src')
 //数据以对象的形式存放在数组中
 allFiles.push({
 title: title,
 star: star,
 pic: pic
 })
 })
 //console.log(allFiles);
 //将数据写入文件中
 fs.writeFile('./files.json', JSON.stringify(allFiles), function (err, data) {
 if (err) {
 throw err
 }
 console.log('文件保存成功');
 })
 })
})
```

