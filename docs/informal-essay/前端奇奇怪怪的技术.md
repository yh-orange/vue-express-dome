## css滤镜filter函数，让照片随意变色，一个属性让网站变黑白效果，就这样任性

**一、常用filter函数，语法【filter：xxx】**

1. blur()，函数将高斯模糊应用于输入图像；

2. contrast()，函数可调整输入图像的对比度，值是 0% 的话，图像会全黑。值是 100%，图像不变。值可以超过 100%，意味着会运用更低的对比。若没有设置值，默认是 1；

3. grayscale()，函数将改变输入图像灰度。amount 的值定义了转换的比例。值为 100% 则完全转为灰度图像，值为 0% 图像无变化。值在 0% 到 100% 之间，则是效果的线性乘数。若未设置值，默认是 0；

4. drop-shadow()，函数对输入图像应用阴影效果；

5. hue-rotate()，函数在输入图像上应用色相旋转。

dome
```html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            /* grayscale百分比越大，黑白感越强烈 */
            /* filter: grayscale(110%); */
        }
        ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            padding: 0;
        }
        .logo {
            width: 100%;
            height: 100%;
        }
        .filter { filter: blur(5px); }
        .filter1 { filter: contrast(200%); }
        .filter2 { filter: grayscale(80%); }
        .filter3 { filter: hue-rotate(90deg); }
        .filter4 { filter: drop-shadow(0 0 2em #646cffaa) }
        .li-image {
            position: relative;
            width: 301px;
            height: 301px;
            margin: 5px;
        }
        .li-image > .filter-name {
            color: red;
            font-size: 30px;
            position: absolute;
            left: 42px;
            top: 15px;
        }
</style>
</head>
<body align="center">
    <ul>
        <li class="li-image">
            <img class="logo" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">无滤镜</span>
        </li>
        <li class="li-image">
            <img class="logo filter" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">blur(5px)</span>
        </li>
        <li class="li-image">
            <img class="logo filter1" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">contrast(200%);</span>
        </li>
        <li class="li-image">
            <img class="logo filter2" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">grayscale(80%);</span>
        </li>
        <li class="li-image">
            <img class="logo filter3" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">hue-rotate(90deg);</span>
        </li>
        <li class="li-image">
            <img class="logo filter4" src="https://ms.bdimg.com/pacific/0/pic/-285567587_-1080009450.jpg?x=0&y=0&h=150&w=242&vh=150.00&vw=242.00&oh=150.00&ow=242.00" alt="图片">
            <span class="filter-name">drop-shadow(0 0 2em #646cffaa)</span>
        </li>
    </ul>
</body>
</html>
```

**滤镜调试技巧：编写基础滤镜样式，用浏览器打开，f12控制台，鼠标点击控制台工具左上角三角形图标，然后选择对应带滤镜的element元素，就会看到滤镜样式，调节滤镜值大小就能实时看到效果。**


**一个属性让网站变黑白效果**

`注意：body开启filter: grayscale(110%);属性后，所有html标签样式都会失效。`

```css
body {
      /* grayscale百分比越大，黑白感越强烈 */
     filter: grayscale(110%);
}
```

## JavaScript中,{}+{}等于多少?

**JavaScript-wat**
在 `JavaScript` 中,加法的规则其实很简单,只有两种情况:你只能把数字和数字相加,或者字符串和字符串相加,所有其他类型的值都会被自动转换成这两种类型的值. 为了能够弄明白这种隐式转换是如何进行的,我们首先需要搞懂一些基础知识.注意:在下面的文章中提到某一章节的时候(比如§9.1),指的都是ECMA-262语言规范([ECMAScript 5.1](https://262.ecma-international.org/5.1/))中的章节.

让我们快速的复习一下.在JavaScript中,一共有两种类型的值:原始值(`primitives`)和对象值(`objects`).原始值有:`undefined`, `null`, `布尔值(booleans)`, `数字(numbers)`,还有`字符串(strings)`.其他的所有值都是对象类型的值,包括数组(`arrays`)和函数(`functions`).

## Web Worker
在HTML5的新规范中，实现了 Web Worker 来引入 js 的 “多线程” 技术, 可以让我们可以在页面主运行的 js 线程中加载运行另外单独的一个或者多个 js 线程。

**一句话： Web Worker专门处理复杂计算的，从此让前端拥有后端的计算能力**
1. 安装`worker-loader`
`npm install worker-loader`

2. 编写`worker.js`
```js
onmessage = function (e) {
  // onmessage获取传入的初始值
  let sum = e.data;
  for (let i = 0; i < 200000; i++) {
    for (let i = 0; i < 10000; i++) {
      sum += Math.random()
    }
  }
  // 将计算的结果传递出去
  postMessage(sum);
}
```

3. 通过行内 `loader` 引入 `worker.js`
`import Worker from "worker-loader!./worker"`

4. 最终代码
```vue
<template>
    <div>
        <button @click="makeWorker">开始线程</button>
        <!--在计算时 往input输入值时 没有发生卡顿-->
        <p><input type="text"></p>
    </div>
</template>

<script>
    import Worker from "worker-loader!./worker";

    export default {
        methods: {
            makeWorker() {
                // 获取计算开始的时间
                let start = performance.now();
                // 新建一个线程
                let worker = new Worker();
                // 线程之间通过postMessage进行通信
                worker.postMessage(0);
                // 监听message事件
                worker.addEventListener("message", (e) => {
                    // 关闭线程
                    worker.terminate();
                    // 获取计算结束的时间
                    let end = performance.now();
                    // 得到总的计算时间
                    let durationTime = end - start;
                    console.log('计算结果:', e.data);
                    console.log(`代码执行了 ${durationTime} 毫秒`);
                });
            }
        },
    }
</script>
```
**计算过程中，在input框输入值，页面一直未发生卡顿**
![worker](/images/informal-essay4.png)

如果直接把这段代码直接丢到主线程中
计算过程中，页面一直处于假死状态，input框无法输入
```js
let sum = 0;
for (let i = 0; i < 200000; i++) {
    for (let i = 0; i < 10000; i++) {
      sum += Math.random()
    }
  }
```
### 开启多线程，并行计算

回到要解决的问题
执行多种运算时，给每种运算开启单独的线程，线程计算完成后要及时关闭

**多线程代码**
```vue
<template>
    <div>
        <button @click="makeWorker">开始线程</button>
        <!--在计算时 往input输入值时 没有发生卡顿-->
        <p><input type="text"></p>
    </div>
</template>

<script>
    import Worker from "worker-loader!./worker";

    export default {
        data() {
          // 模拟数据
          let arr = new Array(100000).fill(1).map(() => Math.random()* 10000);
          let weightedList = new Array(100000).fill(1).map(() => Math.random()* 10000);
          let calcList = [
              {type: 'sum', name: '总和'},
              {type: 'average', name: '算术平均'},
              {type: 'weightedAverage', name: '加权平均'},
              {type: 'max', name: '最大'},
              {type: 'middleNum', name: '中位数'},
              {type: 'min', name: '最小'},
              {type: 'variance', name: '样本方差'},
              {type: 'popVariance', name: '总体方差'},
              {type: 'stdDeviation', name: '样本标准差'},
              {type: 'popStandardDeviation', name: '总体标准差'}
          ]
          return {
              workerList: [], // 用来存储所有的线程
              calcList, // 计算类型
              arr, // 数据
              weightedList // 加权因子
          }
        },
        methods: {
            makeWorker() {
                this.calcList.forEach(item => {
                    let workerName = `worker${this.workerList.length}`;
                    let worker = new Worker();
                    let start = performance.now();
                    worker.postMessage({arr: this.arr, type: item.type, weightedList: this.weightedList});
                    worker.addEventListener("message", (e) => {
                        worker.terminate();

                        let tastName = '';
                        this.calcList.forEach(item => {
                            if(item.type === e.data.type) {
                                item.value = e.data.value;
                                tastName = item.name;
                            }
                        })

                        let end = performance.now();
                        let duration = end - start;
                        console.log(`当前任务: ${tastName}, 计算用时: ${duration} 毫秒`);
                    });
                    this.workerList.push({ [workerName]: worker });
                })
            },
            clearWorker() {
                if (this.workerList.length > 0) {
                    this.workerList.forEach((item, key) => {
                        item[`worker${key}`].terminate && item[`worker${key}`].terminate(); // 终止所有线程
                    });
                }
            }
        },
        // 页面关闭，如果还没有计算完成，要销毁对应线程
        beforeDestroy() {
            this.clearWorker();
        },
    }
</script>
```
    
[原文](https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&mid=2247515242&idx=1&sn=a76f66bf6a7b5f413f058c675fe57714&chksm=9031bf88a746369e68465078ecc0ab956409fb74614d62b4bd1878cd7669c9cb8156b9a0a7ce&scene=126&&sessionid=1662599122#rd)

## async-await

**关于异步处理问题，ES5的回调让我们陷入回调地狱轮回，后来ES6的Promise（Promise不了解？点这了解[1]）让我们脱离轮回，终于，ES7的async-await带我们走向光明。今天我们就来学习一夏 async-await，看看与Promise有何联系和区别。**

### 走进Async-await原理

1. * **async函数返回一个 Promise 对象，可以使用then方法添加回调函数**
```js
// async返回的是Promise对象？
async function testAsync() {
    return 'hello';//上篇文章Promise对象的返回值如果不是Promise，会通过Promise.resolve()转化为Promise，再进行处理
}
const result = testAsync()
console.log(result);//Promise { 'hello' }  说明async返回的是Promise对象
```
那既然async返回的是`Promise对象`，那么async后面的函数可以接.then()或者.catch()...嘛？我们试一试就知道了。
```js
// async返回的是Promise对象,并且可以接Promise的方法？
async function testAsync() {
    // await await等待还是promise对象
    return 'hello'
}
testAsync()
    .then((result)=>{
        console.log(result);
    })
    .catch((error)=>{
        console.log(error);
    })
//hello  妈耶！打印了！说明async返回的是Promise对象，并且可以接Promise的方法，并且！！！默认状态是resolved的
```
上面代码说明，`async函数内部return语句返回的值，会成为then方法回调函数的参数`

2. * **`当async函数内部抛出错误的时候，会导致返回的 Promise 对象变为reject状态`。抛出的错误对象会被.then()方法的第二个回调函数接收或者.catch()方法回调函数接收到。**
```js
// async函数内部抛出错误或者Promise状态为reject
async function testError(){
    //throw new Error('出错啦~~');
    await Promise.reject('出错了');//await前面有return和没有return效果一样
} 
testError()
    // .then(()=>{},(error)=>{console.log(error);})
    .catch(error=>{console.log(error);})
//Error: 出错啦~~
```

3. * **await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。**
```js
// await
async function getName(){
    // return '来自星星的你';
    return await '来自星星的你';//上面直接return等价于这个return
}
getName()
    .then(result=>{console.log(result);})
//来自星星的你
```

4.  **await的使用，必须要有async。**
这便是async-await的浪漫所在了：async返回的是一个Promise对象，await等待的就是这个Promise对象，所以await不能没有async（但是async可以没有await）。有没有被浪漫到？反正我是醉了。如果await没有async会怎么样？报错：
```js
// await没有async会报错
function testAwait(){
    return await '西红柿炒辣椒'
}
testAwait()
    .catch(error=>{
        console.log(error);
    })
//SyntaxError: await is only valid in async function
```

### 深入Async-await规则

1. ** async封装Promise**
```js
// async封装Promise
async function fn1() {
    return '喜羊羊与灰太狼';// //相当于return Promise.resolve('喜羊羊与灰太狼')
    const data = await fn1();//接收data值
}
fn1()//执行async函数，返回的是一个Promise对象
    .then(data => {
        console.log('content =', data)
    })

//content = 喜羊羊与灰太狼
```

2. **await相当于then**

```js
// await---.then()
async function getName(){
    const operate=Promise.resolve('白雪公主')//执行函数
    const name= await operate //await相当于Promise的then  operate.then(name=>{})
    console.log('name:',name)
}
getName();
( async function(){
    const person=await '七个小矮人' //await Promise.resolve('七个小矮人') await后面不跟Promise，也会被封装成Promise
    console.log('person:',person)//400
})();//自执行函数

//name: 白雪公主
//person: 七个小矮人
```

3. **多个await时，按时序执行**
当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。`任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行`。
```js
async function testOrder() {
    await Promise.reject('出错了')//UnhandledPromiseRejectionWarning: 出错了
    await Promise.resolve('hello world'); // 不会执行
}
testOrder();
```

4. **try…catch相当于catch**
如果希望即使前一个异步操作失败，也不要中断后面的异步操作。`可将第一个await放在try...catch结构里面`，这样不管这个异步操作是否成功，第二个await都会执行。
```js
// try...catch
!(async function () {
    const testError = Promise.reject('出错啦~~~')//rejected状态
    // const testError=throw new Error('出错啦~~~');
    try {
        const result = await testError; //await相当于then，但是reject不会触发then
        console.log('success:'+result) //不会输出，因为const result = await testError被报错，被catch捕获
    } catch (error) {
        console.error('error:'+error)//try...catch 相当于Promise的catch
    }

})()
//error:出错啦~~~
```
当await后面是Promise对象的时候，我们`也可直接在await后面直接.catch捕获`错误：
```js
async function testError() {
    await Promise.reject('出错了')
        .catch(error => console.log(error));//这里捕获错误，不会影响下一个await执行
    
    return await Promise.resolve('hello world');
}

testError()
    .then(result => console.log(result))
```

### 解析Async-await语法

```js
// 面试题
function getJSON() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log(2);
            resolve(2)
        }, 2000)
    })
}
async function testAsync() {
    await getJSON()
    console.log(3);
}
testAsync()
//2
//3
```
根据现在的知识面，我们必须知道：

>（1）await不能单独出现，其函数前面一定要有async。
>（2）await会干两件事：
>第一，将写在await后面的代码放到async创建的那个Promise里面执行。
>第二、将写在await下面的代码放到前一个创建的那个Promise对象的.then里面执行。
>3）await返回的也是Promise对象，他只是把await下面的代码放到了await返回的promise的.then里面执行。

这样的话，是不是如鱼得水了。翻译如下：
```js
function getJSON() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log(2);
            resolve(2)
        }, 2000)
    })
}
// 编译成Promise原理
function testAsync() {
    return Promise.resolve().then(() => {
        return getJSON();
    })
        .then(() => {
            console.log(3);

        })
}
testAsync()
```

### 拓展Async-await应用

1. 场景1 解决地狱回调
```js
// Promise解决方式
function doCallback(n) {
    var myPromise = new Promise(function (resolve, reject) {   
        //处理异步任务
        var flag = true;
        setTimeout(function () {
            if (flag) {
                resolve(n)
            }
            else {
                reject('失败')
            }
        },0)
    })
    return myPromise;
}

doCallback(1)
    .then((result) => { //then是成功执行的方法 返回的还是一个Promise对象
        console.log(result);//打印张三  res是执行
        return fn(2);
    })
    .then((result) => {
        console.log(result);
        return fn(3)
    })
    .then((result) => {
        console.log(result);
        return fn(4)
    })
    .then((result) => {
        console.log(result);
    })
    .catch((result) => { //catch是失败执行的方法
        console.log(result);
    })
    //好多.then,形成.then链啦
//1
//2
//3
//4
```
通过以上Promise方法，可以明显解决回调地狱“向右移”的浮夸表现，但是，`Promise是基于 then, catch 的链式调用，但也是基于回调函数`。.then链多多少少还是违背原生代码，显得也不是很优雅。作为回调终极武器，async-await更加贴近于原生代码，我们看一下吧：

```js
//封装一个返回promise的异步任务
function doCallback(str) {
    var myPromise = new Promise(function (resolve, reject) {
        var flag = true;
        setTimeout(function () {
            if (flag) {
                resolve(str)
            } else {
                reject('处理失败')
            }
        })
    })
    return myPromise;
}

//封装一个执行上述异步任务的async函数
async function testAsync() {
    var result1 = await doCallback(1);  //await直接拿到fn()返回的promise的数据，并且赋值给result
    var result2 = await doCallback(2);  //await 后面的代码，都可以看做是异步回调 callback 里的内容，都是异步的
    var result3 = await doCallback(3);
    var result4 = await doCallback(4);
    console.log(result1);
    console.log(result2);
    console.log(result3);
    console.log(result4);
}//这样是不是简洁优雅多了呢？
//执行函数
testAsync();
//1
//2
//3
//4
```

有了 async-await、promise 还有必要学习吗？通过上面async-await的解决方案可以瞧见，async / await 和 Promise 并不互斥，二者相辅相成。同时async / await 并不能改变异步的本质

## localStorage 的高阶用法

### 设计
封装之前先梳理下所需功能，并要做成什么样，采用什么样的规范，部分主要代码片段是以 `localStorage`作为示例，最后会贴出完整代码的。可以结合项目自行优化，也可以直接使用。
```js
// 区分存储类型 type
// 自定义名称前缀 prefix
// 支持设置过期时间 expire
// 支持加密可选，开发环境下未方便调试可关闭加密

// 支持数据加密 这里采用 crypto-js 加密 也可使用其他方式

// 判断是否支持 Storage isSupportStorage

// 设置 setStorage

// 获取 getStorage

// 是否存在 hasStorage

// 获取所有key getStorageKeys

// 根据索引获取key getStorageForIndex

// 获取localStorage长度 getStorageLength

// 获取全部 getAllStorage

// 删除 removeStorage

// 清空 clearStorage

//定义参数 类型 window.localStorage,window.sessionStorage,
const config = {
    type: 'localStorage', // 本地存储类型 localStorage/sessionStorage
    prefix: 'SDF_0.0.1', // 名称前缀 建议：项目名 + 项目版本
    expire: 1, //过期时间 单位：秒
    isEncrypt: true // 默认加密 为了调试方便, 开发过程中可以不加密
}
```

### 设置 setStorage
`Storage` 本身是不支持过期时间设置的，要支持设置过期时间，可以效仿 `Cookie` 的做法，`setStorage(key,value,expire)` 方法，
接收三个参数，第三个参数就是设置过期时间的，用相对时间，单位秒，要对所传参数进行类型检查。可以设置统一的过期时间，
也可以对单个值得过期时间进行单独配置。两种方式按需配置。
```js
// 设置 setStorage
export const setStorage = (key,value,expire=0) => {
    if (value === '' || value === null || value === undefined) {
        value = null;
    }

    if (isNaN(expire) || expire < 1) throw new Error("Expire must be a number");

    expire = (expire?expire:config.expire) * 60000;
    let data = {
        value: value, // 存储值
        time: Date.now(), //存值时间戳
        expire: expire // 过期时间
    };

    window[config.type].setItem(key, JSON.stringify(data));
}
```

### 获取 getStorage
首先要对 `key` 是否存在进行判断，防止获取不存在的值而报错。对获取方法进一步扩展，只要在有效期内获取 `Storage` 值，
就对过期时间进行续期，如果过期则直接删除该值。并返回 `null`
```js
export const getStorage = (key) => {
    // key 不存在判断
    if (!window[config.type].getItem(key) || JSON.stringify(window[config.type].getItem(key)) === 'null'){
        return null;
    }

    // 优化 持续使用中续期
    const storage = JSON.parse(window[config.type].getItem(key));
    console.log(storage)
    let nowTime = Date.now();
    console.log(config.expire*6000 ,(nowTime - storage.time))
    // 过期删除
    if (storage.expire && config.expire*6000 < (nowTime - storage.time)) {
        removeStorage(key);
        return null;
    } else {
        // 未过期期间被调用 则自动续期 进行保活
        setStorage(key,storage.value);
        return storage.value;
    }
}
```

**获取所有值**
```js
// 获取全部 getAllStorage
export const getAllStorage = () => {
    let len = window[config.type].length // 获取长度
    let arr = new Array() // 定义数据集
    for (let i = 0; i < len; i++) {
        // 获取key 索引从0开始
        let getKey = window[config.type].key(i)
        // 获取key对应的值
        let getVal = window[config.type].getItem(getKey)
        // 放进数组
        arr[i] = { 'key': getKey, 'val': getVal, }
    }
    return arr
}
```

**删除 removeStorage**
// 名称前自动添加前缀
const autoAddPrefix = (key) => {
    const prefix = config.prefix ? config.prefix + '_' : '';
    return  prefix + key;
}

// 删除 removeStorage
export const removeStorage = (key) => {
    window[config.type].removeItem(autoAddPrefix(key));
}

**清空 clearStorage**
```js
// 清空 clearStorage
export const clearStorage = () => {
    window[config.type].clear();
}
```

**加密、解密**

加密采用的是 `crypto-js`
```text
// 安装crypto-js
npm install crypto-js

// 引入 crypto-js 有以下两种方式
import CryptoJS from "crypto-js";
// 或者
const CryptoJS = require("crypto-js");
```
对 `crypto-js` 设置密钥和密钥偏移量,可以采用将一个私钥经 `MD5` 加密生成16位密钥获得。
```js
// 十六位十六进制数作为密钥
const SECRET_KEY = CryptoJS.enc.Utf8.parse("3333e6e143439161");
// 十六位十六进制数作为密钥偏移量
const SECRET_IV = CryptoJS.enc.Utf8.parse("e3bbe7e3ba84431a");
```
对加密方法进行封装
```js
/**
 * 加密方法
 * @param data
 * @returns {string}
 */
export function encrypt(data) {
  if (typeof data === "object") {
    try {
      data = JSON.stringify(data);
    } catch (error) {
      console.log("encrypt error:", error);
    }
  }
  const dataHex = CryptoJS.enc.Utf8.parse(data);
  const encrypted = CryptoJS.AES.encrypt(dataHex, SECRET_KEY, {
    iv: SECRET_IV,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });
  return encrypted.ciphertext.toString();
};
```
对解密方法进行封装
/**
 * 解密方法
 * @param data
 * @returns {string}
 */
export function decrypt(data) {
  const encryptedHexStr = CryptoJS.enc.Hex.parse(data);
  const str = CryptoJS.enc.Base64.stringify(encryptedHexStr);
  const decrypt = CryptoJS.AES.decrypt(str, SECRET_KEY, {
    iv: SECRET_IV,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });
  const decryptedStr = decrypt.toString(CryptoJS.enc.Utf8);
  return decryptedStr.toString();
}
在存储数据及获取数据中进行使用：

### 使用
使用的时候你可以通过 import 按需引入，也可以挂载到全局上使用，一般建议少用全局方式或全局变量，为后来接手项目继续开发维护的人，追查代码留条便捷之路！不要为了封装而封装，尽可能基于项目需求和后续的通用，以及使用上的便捷。比如获取全部存储变量，如果你项目上都未曾用到过，倒不如删减掉，留着过年也不见得有多香，不如为减小体积做点贡献！

### 完整代码
```js
/***
 * title: storage.js
 * Author: Gaby
 * Email: xxx@126.com
 * Time: 2022/6/1 17:30
 * last: 2022/6/2 17:30
 * Desc: 对存储的简单封装
 */
 
import CryptoJS from 'crypto-js';

// 十六位十六进制数作为密钥
const SECRET_KEY = CryptoJS.enc.Utf8.parse("3333e6e143439161");
// 十六位十六进制数作为密钥偏移量
const SECRET_IV = CryptoJS.enc.Utf8.parse("e3bbe7e3ba84431a");

// 类型 window.localStorage,window.sessionStorage,
const config = {
    type: 'localStorage', // 本地存储类型 sessionStorage
    prefix: 'SDF_0.0.1', // 名称前缀 建议：项目名 + 项目版本
    expire: 1, //过期时间 单位：秒
    isEncrypt: true // 默认加密 为了调试方便, 开发过程中可以不加密
};

// 判断是否支持 Storage
export const isSupportStorage = () => {
    return (typeof (Storage) !== "undefined") ? true : false;
};

// 设置 setStorage
export const setStorage = (key, value, expire = 0) => {
    if (value === '' || value === null || value === undefined) {
        value = null;
    }

    if (isNaN(expire) || expire < 0) throw new Error("Expire must be a number");

    expire = (expire ? expire : config.expire) * 1000;
    let data = {
        value: value, // 存储值
        time: Date.now(), //存值时间戳
        expire: expire // 过期时间
    };
    
    const encryptString = config.isEncrypt 
    ? encrypt(JSON.stringify(data))
    : JSON.stringify(data);
    
    window[config.type].setItem(autoAddPrefix(key), encryptString);
};

// 获取 getStorage
export const getStorage = (key) => {
    key = autoAddPrefix(key);
    // key 不存在判断
    if (!window[config.type].getItem(key) || JSON.stringify(window[config.type].getItem(key)) === 'null') {
        return null;
    }

    // 优化 持续使用中续期
    const storage = config.isEncrypt 
    ? JSON.parse(decrypt(window[config.type].getItem(key))) 
    : JSON.parse(window[config.type].getItem(key));
    
    let nowTime = Date.now();

    // 过期删除
    if (storage.expire && config.expire * 6000 < (nowTime - storage.time)) {
        removeStorage(key);
        return null;
    } else {
        // 未过期期间被调用 则自动续期 进行保活
        setStorage(autoRemovePrefix(key), storage.value);
        return storage.value;
    }
};

// 是否存在 hasStorage
export const hasStorage = (key) => {
    key = autoAddPrefix(key);
    let arr = getStorageAll().filter((item)=>{
        return item.key === key;
    });
    return arr.length ? true : false;
};

// 获取所有key
export const getStorageKeys = () => {
    let items = getStorageAll();
    let keys = [];
    for (let index = 0; index < items.length; index++) {
        keys.push(items[index].key)
    }
    return keys
};

// 根据索引获取key
export const getStorageForIndex = (index) => {
    return window[config.type].key(index)
};

// 获取localStorage长度
export const getStorageLength = () => {
    return window[config.type].length
};

// 获取全部 getAllStorage
export const getStorageAll = () => {
    let len = window[config.type].length // 获取长度
    let arr = new Array() // 定义数据集
    for (let i = 0; i < len; i++) {
        // 获取key 索引从0开始
        let getKey = window[config.type].key(i);
        // 获取key对应的值
        let getVal = window[config.type].getItem(getKey);
        // 放进数组
        arr[i] = {'key': getKey, 'val': getVal,}
    }
    return arr
};

// 删除 removeStorage
export const removeStorage = (key) => {
    window[config.type].removeItem(autoAddPrefix(key));
};

// 清空 clearStorage
export const clearStorage = () => {
    window[config.type].clear();
};

// 名称前自动添加前缀
const autoAddPrefix = (key) => {
    const prefix = config.prefix ? config.prefix + '_' : '';
    return  prefix + key;
};

// 移除已添加的前缀
const autoRemovePrefix = (key) => {
    const len = config.prefix ? config.prefix.length+1 : '';
    return key.substr(len)
    // const prefix = config.prefix ? config.prefix + '_' : '';
    // return  prefix + key;
};

/**
 * 加密方法
 * @param data
 * @returns {string}
 */
const encrypt = (data) => {
    if (typeof data === "object") {
        try {
            data = JSON.stringify(data);
        } catch (error) {
            console.log("encrypt error:", error);
        }
    }
    const dataHex = CryptoJS.enc.Utf8.parse(data);
    const encrypted = CryptoJS.AES.encrypt(dataHex, SECRET_KEY, {
        iv: SECRET_IV,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.ciphertext.toString();
};

/**
 * 解密方法
 * @param data
 * @returns {string}
 */
const decrypt = (data) => {
    const encryptedHexStr = CryptoJS.enc.Hex.parse(data);
    const str = CryptoJS.enc.Base64.stringify(encryptedHexStr);
    const decrypt = CryptoJS.AES.decrypt(str, SECRET_KEY, {
        iv: SECRET_IV,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    const decryptedStr = decrypt.toString(CryptoJS.enc.Utf8);
    return decryptedStr.toString();
};
```

## 前端性能优化到底该怎么做

**前端性能优化核心就是两点**

* **保证资源更快的 加载速度**：达到越快渲染越快，视图展现就越快
* **保证视图更快的 渲染速度/交互速度**：用户与页面交互，前提是页面要渲染出来，其次是页面需要尽早反馈，目的就是保证用户良好的体验性

>从输入 `URL` 到页面加载完成发生了什么？

在这还是要简单的总结一下核心内容：

* 进行 `DNS` 解析
* 建立 `TCP` 连接
* 客户端发送 `HTTP` 请求
* 服务端响应 `HTTP` 资源
* 浏览器获取响应内容，进行解析和渲染
***

### RAIL 模型
`Google` 为前端页面性能的评估提出了 `RAIL` 模型，核心内容如下：

* `Response` 响应
* `Animation` 动画
* `Idle` 空闲
* `Load` 加载

[RAIL 模型](/images/informal-essay5.png)

### 常规性能指标
性能指标其实有不少的内容，但在这我们指列举比较常用的几种：

* **首次绘制（`First Paint，FP`）**
    * 在渲染进程确认要渲染当前响应资源后，渲染进程会先创建一个空白页面，通常把创建空白页面的这个时间点称为 `First Paint`，简称 `FP`
    * 所谓的 `白屏时间` 其实指的就是创建这个空白页面到浏览器开始渲染非空白内容的时间，比如页面背景发生变化等

* **首次内容绘制（`First Contentful Paint，FCP`）**
    * 当用户看见一些 "内容" 元素被绘制在页面上的时间点，和白屏是不一样，它可以是 `文本` 首次绘制，或 `SVG` 首次出现，或 `Canvas` 首次绘制等，即当页面中绘制了第一个 `像素` 时，这个时间点称为 `First Content Paint`，简称 `FCP`

* **首屏时间 / 最大内容绘制（`Largest Contentful Paint, LCP`）**
    * `LCP` 是一种新的性能度量标准，`LCP` 侧重于用户体验的性能度量标准，与现有度量标准相比，更容易理解与推理，当首屏内容完全绘制完成时，这个时间点称为 `Largest Content Paint`，简称 `LCP`
    * 最大内容绘制应在 `2.5s` 内完成

* **首次输入延迟（`First Input Delay, FID`）**
    * `FID` 测量的是当用户第一次在页面上交互的时候（**点击链接**、**点击按钮** 或 **自定义基于 js 的事件**），到浏览器实际开始处理这个事件的时间
    * 首次输入延迟应在 **100ms** 内完成

* **累积布局偏移（`Cumulative Layout Shift, CLS`)**
    * `CLS` 是为了测量 视觉稳定性，以便提供良好的用户体验
    * 累积布局偏移应保持在 `0.1` 或更少

* **首字节达到时间（`Time to First Byte，TTFB`）**
    * 指的是浏览器开始收到服务器响应数据的时间（**后台处理时间** + **重定向时间**），是反映服务端响应速度的重要指标
    * **`TTFB` 时间如果超过 `500ms`，用户在打开网页的时就会感觉到明显的等待**
    
通过上述内容了解了性能指标的相关内容和一些阀值，那么接下来的问题是我们怎么获取一个网站的具体性能指标数据呢？

为了方便还是得使用工具或者说是 `API`，当然可以 **自定义页面性能指标** 的计算方式，比如有些就是通过计算当前页面 `DOM` 的 **总节点数** 和 **嵌套层级** 来计算一个网站的分数等，这里就不再额外介绍。
***

### Performance 面板（Google）




































