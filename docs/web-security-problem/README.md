# Web安全问题

关于Web安全，我们最早听到最多的就是`SQL注入`。例如用户在系统登录界面输入用户名和密码，提交以后，后端直接拿到数据就拼接SQL语句去查询数据库。如果在输入时进行了恶意的SQL拼装，那么最后生成的`SQL`就有问题，黑客就可以从数据库中拖出关键信息。

我们可以通过在后端用`PDO扩展`的方式访问数据库和对用户输入数据进行多重验证的方式来避免`SQL注入`。

而现在前端我们遇到的web安全问题比较典型的有`XSS攻击`和`CSRF攻击`这两种。本次主要来说说对于这两种攻击，先解释其实现原理还有我们都有哪些方法可以来应对。

## XSS攻击

> `XSS(Cross-site Scripting, 跨站脚本攻击)`

避免与`CSS`重名，所以简写成`XSS`了。原理就是通过发布文章、发布评论等方式，将一段恶意的JS代码输入进去。然后别人再看这篇文章、评论时，之前注入的这段恶意JS代码就执行了。JS代码一旦执行就跟网页原有的JS有同样的权限，可以获取`cookie`等。

**解决办法有四个：**

1. `CSP(Content-Security-Policy)`

内容安全策略是`http`协议中协议头的一个字段，也可以通过`html`的`meta`标签进行控制。只要在返回的`http`头中定义：

```
'Content-type':'text/html',
'Content-Security-Policy':'default-src http: https:'
```

那么返回的`html`文件就只能通过`http`和`https`外链加载`js`脚本的方式来执行`js`代码，而不能执行内联的`js`代码。

这样就防止了恶意内联js代码的执行。此外这个标签还可以设置加载哪些域名下的js文件等，更多信息请查阅 MDN CSP文档。

2. 对`cookie`设置`http-only`

可以对`cookie`设置`http-only`来禁止通过JS访问`cookie`，减少`XSS`攻击。

3. 对用户输入的内容进行`escape`验证

目前已经有一些`npm`库例如`xss-escape`,通过把有`XSS`攻击危险的字符转换成`html`实体字符，再放到后端存储，下次在前端渲染的时候，浏览器就不会把实体字符当做脚本来执行了，而是当成实体编码解码之后进行显示。

4. 后端对有`XSS`嫌疑的内容进行过滤

## CSRF攻击

> CSRF(Cross-site request forgery，跨站请求伪造)

`CSRF`是借用了当前操作者的身份来偷偷完成了某个请求操作，而不是为了拿到用户信息。

攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

### `CSRF攻击`攻击原理及过程如下：

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；

5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带`Cookie`信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的`Cookie`信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 

### `CSRF`漏洞检测：

检测`CSRF`漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉`Referer`字段后再重新提交，如果该提交还有效，那么基本上可以确定存在`CSRF`漏洞。

### 防御CSRF攻击：

目前防御 `CSRF` 攻击主要有三种策略：验证 `HTTP Referer` 字段；在请求地址中添加 `token` 并验证；在 `HTTP`头中自定义属性并验证。

1. 验证 `HTTP Referer` 字段

根据 `HTTP` 协议，在 `HTTP` 头中有一个字段叫 `Referer`，它记录了该 `HTTP` 请求的来源地址。

在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 `http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory`，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 `Referer` 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 `Referer` 是指向黑客自己的网站。

因此，要防御 `CSRF` 攻击，银行网站只需要对于每一个转账请求验证其 `Referer` 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 `Referer` 是其他网站的话，则有可能是黑客的 `CSRF` 攻击，拒绝该请求。

2. 在请求地址中添加 `token` 并验证

 `CSRF` 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 `cookie` 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 `cookie` 来通过安全验证。要抵御 `CSRF`，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 `cookie` 之中。
 
 可以在 `HTTP` 请求中以参数的形式加入一个随机产生的 `token`，并在服务器端建立一个拦截器来验证这个 `token`，如果请求中没有 `token` 或者 `token `内容不正确，则认为可能是 `CSRF` 攻击而拒绝该请求。

3. 在 `HTTP` 头中自定义属性并验证

这种方法也是使用 `token` 并进行验证，和上一种方法不同的是，这里并不是把 `token` 以参数的形式置于 `HTTP` 请求之中，而是把它放到 `HTTP` 头中自定义的属性里。

通过 `XMLHttpRequest` 这个类，可以一次性给所有该类请求加上 `csrftoken` 这个 `HTTP` 头属性，并把 `token` 值放入其中。这样解决了上种方法在请求中加入 `token` 的不便，同时，通过 `XMLHttpRequest` 请求的地址不会被记录到浏览器的地址栏，也不用担心 `token `会透过 `Referer` 泄露到其他网站中去。








