# 浏览器对象 BOM
## 浏览器对象 BOM

### 定义

各个浏览器厂商针对`DOM`标准实现的用来获取或设置浏览器的属性、行为的一个对象。

BOM是由哪些对象组成？

* `window` : BOM中最顶层对象
* `screen` ：屏幕对象
* `location`： 地址栏对象
* `history`：历史记录对象
* `navigator`： 导航对象
* `document` ： 文档对象
* `frames` :框架集

### window对象

BOM的核心对象是 `window`，它表示浏览器的一个实例。

在浏览器中，`window` 对象有双重角色，它既是通过 `JavaScript` 访问浏览器窗口的一个接口，又是 `ECMAScript` 规定的 `Global` 对象。

这意味着在网页中定义的任何一个对象、变量和函数，都以 `window` 作为其 `Global` 对象，因此有权访问 `parseInt()` 等方法。

1. 全局作用域

全局变量不能通过 `delete` 操作符删除，而直接在 `window` 对象上的定义的属性可以。

```js
let age = 29; 
window.color = "red"; 
//在 IE < 9 时抛出错误，在其他所有浏览器中都返回 false 
delete window.age; 
//在 IE < 9 时抛出错误，在其他所有浏览器中都返回 true 
delete window.color; //returns true 
alert(window.age); // 29 
alert(window.color); // undefined
```

2. 窗口位置

```javascript
let leftPos = (typeof window.screenLeft == "number") ? 
 window.screenLeft : window.screenX; 
let topPos = (typeof window.screenTop == "number") ? 
 window.screenTop : window.screenY;
```
3. 窗口大小

```js
let pageWidth = window.innerWidth, pageHeight = window.innerHeight; 
if (typeof pageWidth != "number"){ 
    if (document.compatMode == "CSS1Compat"){ 
        pageWidth = document.documentElement.clientWidth; 
        pageHeight = document.documentElement.clientHeight; 
    } else { 
        pageWidth = document.body.clientWidth; 
        pageHeight = document.body.clientHeight; 
    } 
}
```
::: tip TIP
        
另外，使用 `resizeTo()`和 `resizeBy()`方法可以调整浏览器窗口的大小。

这两个方法都接收两个参数，其中 `resizeTo()` 接收浏览器窗口的新宽度和新高度，而`resizeBy()`接收新窗口与原窗口的宽度和高度之差。
:::

4. 导航和打开窗口

使用 `window.open()`方法既可以导航到一个特定的`url`，也可以打开一个新的浏览器窗口。

>window.open(url,name,features,replace);

5. 间歇调用和超时调用

`JavaScript` 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。
```javascript
setTimeout(function() { 
	alert("Hello world!"); 
}, 1000);
```
*第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。*

`JavaScript` 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个`JavaScript`任务队列。这些任务会按照将它们添加到队列的顺序执行。

*`setTimeout()`的第二个参数告诉 `JavaScript` 再过多长时间把当前任务添加到队列中。*

如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。

调用 `setTimeout()`之后，该方法会返回一个数值 ID，表示超时调用。

这个超时调用`ID`是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用`clearTimeout()`方法并将相应的超时调用ID作为参数传递给它，如下所示:

```javascript
// 设置超时调用
let timeoutId = setTimeout(function() { 
	alert("Hello world!"); 
}, 1000); 
// 注意：把它取消
clearTimeout(timeoutId);
```

间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。

```javascript
let num = 0; 
let max = 10; 
let intervalId = null; 
function incrementNumber() { 
	num++; 
 	// 如果执行次数达到了 max 设定的值，则取消后续尚未执行的调用
	 if (num == max) { 
	 	clearInterval(intervalId); 
	 	alert("Done"); 
	 } 
} 
intervalId = setInterval(incrementNumber, 500);
```

在这个例子中，变量 `num` 每半秒钟递增一次，当递增到最大值时就会取消先前设定的间歇调用。这个模式也可以使用超时调用来实现，如下所示:

```javascript
let num = 0; 
let max = 10; 
function incrementNumber() { 
    num++; 
    // 如果执行次数未达到 max 设定的值，则设置另一次超时调用
    if (num < max) { 
 	    setTimeout(incrementNumber, 500); 
    } else { 
 	    alert("Done"); 
    } 
} 
setTimeout(incrementNumber, 500);
```
::: tip TIP
        
在使用超时调用时，没有必要跟踪超时调用`ID`，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。

一般认为，使用超时调用来模拟`间歇调用`的是一种最佳模式。在开发环境下，很少使用真正的`间歇调用`，原因是后一个间歇调用可能会在前一个`间歇调`用结束之前启动。而像前面示例中那样使用`超时调用`，则完全可以避免这一点。

另外使用定时器的时候需要慎重，注意及时清理，避免内存溢出。
:::

### location 对象
`location` 是最有用的 `BOM` 对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。

假设我们有如下一个url:

>http://localhost:8000/#/user/login?a=1&b=2

| 属性 | 例子 | 描述|
| --- | --- | --- |
|origin|	http://localhost:8000|	返回主机等信息|
|protocol|	http|	返回当前地址的协议类型 http 、 https|
|host|	localhost:8000|	返回当前的域名及端口号|
|hostname|	localhost	|返回当前的域名|
|port|	8000	|返回当前地址的端口号|
|pathname|	/	|返回当前页面所在目录路径|
|search|	""	|返回当前地址所带的参数如果没有返回空字符串|
|hash|	#/user/login?a=1&b=2	|返回当前地址所包含的hash值，如果没有hash值则返回空字符串|
|href|	http://localhost:8000/#/user/login?a=1&b=2	|返回当前地址的完整url|

跳转操作

* window.location = url
* window.location.href = url
* window.location.assign(url)
* window.location.replace(url) // 无法返回上个页面
* window.location.reload(); // 重新加载（有可能从缓存中加载）
* window.location.reload(true); // 重新加载（从服务器重新加载）

### navigator 对象

Navigator 对象包含有关浏览器的信息。

:boom: 注意： 没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象。
*Navigator 对象属性*
|属性|描述|
|---|---|
|appCodeName|	返回浏览器的代码名。|
|appMinorVersion|	返回浏览器的次级版本。|
|appName|	返回浏览器的名称。|
|appVersion|	返回浏览器的平台和版本信息。|
|browserLanguage|	返回当前浏览器的语言。|
|cookieEnabled|	返回指明浏览器中是否启用 cookie 的布尔值。|
|cpuClass|	返回浏览器系统的 CPU 等级。|
|onLine|	返回指明系统是否处于脱机模式的布尔值。|
|platform|	返回运行浏览器的操作系统平台。|
|systemLanguage|	返回 OS 使用的默认语言。|
|userAgent|	返回由客户机发送服务器的 user-agent 头部的值。|
|userLanguage|	返回 OS 的自然语言设置。|

*Navigator 对象方法*
|方法|描述|
|---|---|
|javaEnabled()|	规定浏览器是否启用 Java。|
|taintEnabled()|	规定浏览器是否启用数据污点 (data tainting)。|


*Navigator 对象描述*
`Navigator` 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。

虽然这个对象的名称显而易见的是 `Netscape` 的 `Navigator` 浏览器，但其他实现了 `JavaScript` 的浏览器也支持这个对象。

Navigator 对象的实例是唯一的，可以用 `Window` 对象的 `navigator` 属性来引用它。

### history对象

history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。

history.back();// 回退一页
history.forword();// 前进一页
history.go(number | url) // 跳转指定页数或者页面
history.length // 保存着历史记录的数量

### 客户端检测

*在可能的情况下，要尽量使用`typeof`进行能力检测。*

在浏览器环境下测试任何对象的某个特性是否存在，要使用下面这个函数：

```javascript
// 作者：Peter Michaux 
function isHostMethod(object, property) { 
	let t = typeof object[property]; 
 	return t === 'function' || (!!( t === 'object' && object[property])) || t == 'unknown'; 
}

// 可以像下面这样使用这个函数：
result = isHostMethod(xhr, "open"); //true 
result = isHostMethod(xhr, "foo"); //false
```

### 有趣的userAgent

>"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36"

基于 `WebKit` 的所有浏览器都将自己标识为 `Mozilla 5.0`，与基于 `Gecko` 的浏览器完全一样。

1. 用户代理字符串检测技术

```javascript
export function OS() {
  const u = navigator.userAgent
  // 移动终端浏览器版本信息
  return {
    trident: u.indexOf('Trident') > -1, // IE内核
    presto: u.indexOf('Presto') > -1, // opera内核
    webKit: u.indexOf('AppleWebKit') > -1, // 苹果、谷歌内核
    gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') === -1, // 火狐内核
    mobile: !!u.match(/AppleWebKit.*Mobile.*/), // 是否为移动终端
    ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), // ios终端
    android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1 || u.indexOf('UCBrowser') > -1, // android终端或者uc浏览器
    iPhone: u.indexOf('iPhone') > -1, // 是否为iPhone或者QQHD浏览器
    iPad: u.indexOf('iPad') > -1, // 是否iPad
    webApp: u.indexOf('Safari') === -1, // 是否web应该程序，没有头部与底部
    weixin: u.indexOf('MicroMessenger') > -1, // 是否微信
    chrome: u.indexOf('Chrome') > -1,
    ali: u.indexOf('Alipay') > -1,
    qq: u.match(/\sQQ/i), // 是否QQ
    safari: u.indexOf('Safari') > -1,
  }
}
```

### Web Components

`Web Components API`是右 `Google` 一直在推行的一种实现组件的方式,相比第三方框架，原生组件简单直接，符合直觉，不用加载任何外部模块，代码量小,但是实际书写上和可维护性也不是特别的好。
不太使用。
`dome` 如下
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>JS Bin</title>
</head>
<body>
<user-card
  image="https://semantic-ui.com/images/avatar2/large/kristy.png"
  name="User Name"
  email="yourmail@some-email.com"
></user-card>
  
<template id="userCardTemplate">
  <style>
   :host {
     display: flex;
     align-items: center;
     width: 450px;
     height: 180px;
     background-color: #d4d4d4;
     border: 1px solid #d5d5d5;
     box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
     border-radius: 3px;
     overflow: hidden;
     padding: 10px;
     box-sizing: border-box;
     font-family: 'Poppins', sans-serif;
   }
   .image {
     flex: 0 0 auto;
     width: 160px;
     height: 160px;
     vertical-align: middle;
     border-radius: 5px;
   }
   .container {
     box-sizing: border-box;
     padding: 20px;
     height: 160px;
   }
   .container > .name {
     font-size: 20px;
     font-weight: 600;
     line-height: 1;
     margin: 0;
     margin-bottom: 5px;
   }
   .container > .email {
     font-size: 12px;
     opacity: 0.75;
     line-height: 1;
     margin: 0;
     margin-bottom: 15px;
   }
   .container > .button {
     padding: 10px 25px;
     font-size: 12px;
     border-radius: 5px;
     text-transform: uppercase;
   }
  </style>
  
  <img class="image">
  <div class="container">
    <p class="name"></p>
    <p class="email"></p>
    <button class="button">Follow John</button>
  </div>
</template>

</body>
</html>
```
```javascript
class UserCard extends HTMLElement {
  constructor() {
    super();
    var shadow = this.attachShadow( { mode: 'closed' } );
    
    var templateElem = document.getElementById('userCardTemplate');
    var content = templateElem.content.cloneNode(true);
    content.querySelector('img').setAttribute('src', this.getAttribute('image'));
    content.querySelector('.container>.name').innerText = this.getAttribute('name');
    content.querySelector('.container>.email').innerText = this.getAttribute('email');

    shadow.appendChild(content);
  }
}
window.customElements.define('user-card', UserCard);
```

常见坑如下
1. 组件内部事件的回调
比如，一个弹窗组件（`<my-dialog></my-dialog>`）中的确定按钮，那么它的事件是如何触发的呢？
```javascript
class myDialog extends HTMLElement {
  // ...
  connectedCallback() {
    const shadowRoot = this.attachShadow({ mode: 'open' });
    shadowRoot.innerHTML = `
      <div class="dialog">
        <div class="dialog-content">
          <div class="dialog-body">
            弹窗内容
          </div>

          <button id="okBtn">确定</button>
        </div>
      </div>
    `;

    shadowRoot.querySelector('#okBtn').addEventListener('click', () => {
      // 组件内部定义事件
      this.dispatchEvent(new CustomEvent('okBtnFn'));
    });
  }
}

customElements.define('my-dialog', myDialog);
```
现在方案是 `custom` `element` 内部自定义事件 `new CustomEvent()`，外部用 `addEventListener` 监听。这样的写法是很丑陋的，仿佛又回到了原生 `JS` 写应用的时代。

```html
<my-dialog></my-dialog>

<script> export default {
    created() {
      document.addEventListener('okBtnFn', function(){
        // 点击弹窗按钮，触发回调事件
      });
    }
  } </script>
```

2. 组件样式覆盖

对于开发者来说，难免会遇到需要调整组件内部样式的时候。无论你是使用antd、vant还是使用其它组件库，但 WC 的 CSS 防污染机制导致你很难修改内部样式。这需要你付出一些代价来变相的修改内部样式.

3. 组件内部资源相对路径问题

就目前来说，任何直接基于 Custom Element v1, Template 和 HTML Import 的组件都无法做到完全资源独立 —— 在不知道使用方环境且不给使用方增加额外限制的情况下使用内部封装的任何资源文件。比如如果你有一个自定义 icon 组件：

```javascript
class MyIcon extends HTMLElement {
    static get observedAttributes() { return ['name','size','color'] }
    constructor() {
        super();
        const shadowRoot = this.attachShadow({ mode: 'open' });
        shadowRoot.innerHTML = `
            <svg class="icon" id="icon" aria-hidden="true" viewBox="0 0 1024 1024">
                <use id="use"></use>
            </svg>
        `
    }

    attributeChangedCallback (name, oldValue, newValue) {
        if( name == 'name' && this.shadowRoot){
            // 如果使用的项目中，根目录没有 icon.svg 文件，那就 gg
            this.use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `./icon.svg#icon-${newValue}`);
        }
    }
}

customElements.define('my-icon', MyIcon);
```
如果使用的项目中，根目录没有 icon.svg 文件，那就 gg。如果你在这里使用 cdn 路径，就会出现跨域问题。

4. form表单类组件 value 获取问题

5. 其他
缺少数据绑定和状态管理也是 WC 存在的缺陷，此处不再赘述。


* WC 指在丰富 HTML 的 DOM 特性，让 HTML 拥有更强大的复用能力
* WC 可以直接当做原生标签，在任何前端框架和无框架中运行
* 结合当下的主流技术栈来说，WC 当前主要问题在于复杂的组件中，数据通信和事件传递存在一定使用成本
* 兼容问题，比如可以覆盖内部样式的 :part 方法