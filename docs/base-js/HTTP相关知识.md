## `HTTP` 定义
***

>`HTTP`(`HyperText Transfer Protocal`)超文本传输协议，它通常运行在 `TCP` 之上，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，`HTTP` 协议规定了超文本传输所要遵守的规则。

通过 `HTTP` 或者 `HTTPS` 协议请求的资源由统一资源标识符URL(Uniform Resource Identifiers)来标识。

## `HTTP` 特点
***

`http` 主要有以下几个特点:

* 仅支持(客户端/服务端)模式。意味着该请求只能通过客户端发起,服务端响应。

* 简单快速、灵活。

* `HTTP` 协议是无状态的。这意味着客户端和服务端之间无法知晓当前对方的状态信息，`HTTP` 请求本身是不带有任何状态存储的。但实际情况下，客户端和服务端必然需要状态的认证和交互，所以就引入了 `Cookie`、`Session`， 用于存储当前浏览器的一些状态信息，每次通过独立的 `HTTP` 请求进行收发，从而解决这个问题。

* `HTTP` 请求互相独立。`HTTP` 互相之间都是一个独立的个体请求，在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应 `HTML` 页面，然后浏览器收到响应之后发现页面还引用了其他的资源，例如，`CSS`，`JS` 文件，图片等等，还会自动发送 `HTTP` 请求获取这些需要的资源。

* `HTTP` 协议基于 `TCP` 协议。`HTTP` 协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节，底层是基于 `TCP` 实现的。现在使用的版本当中是默认持久连接的，也就是多次 `HTTP` 请求使用一个 `TCP 连接`。

:::warning WARNING

注意：`HTTP` 请求和 `TCP` 连接是不一样的，`HTTP` 是在 `TCP` 连接建立的基础上而发起的传输请求，在同一个 `TCP` 连接通道下，可以发送多个 `HTTP` 请求，举个例子的话就是高速公路和车子的关系。
:::

## `HTTP` 请求响应模型
***

`HTTP` 由请求和响应构成，是一个标准的客户端服务器模型(`B/S`)。

`HTTP` 协议永远是客户端发起，然后服务器返回响应。

![请求响应模型](/images/base-js45.png)

:::tip TIP

`HTTP` 是一个无状态的协议。

无状态是指客户机（`Web浏览器`）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(`response`)，连接就被关闭了，在服务器端不保留连接的有关信息.

`HTTP` 遵循请求(`Request`)/应答(`Response`)模型。客户机（`浏览器`）向服务器发送请求，服务器处理请求并返回适当的应答。所有 `HTTP` 连接都被构造成一套请求和应答。
:::

## `OSI`七层网络模型
***

![七层网络模型](/images/base-js46.png)

### 物理层

>通过光缆、电缆、无线电波等方式将设备连接起来组网，以二进制的数据形式在物理媒体上传输比特流0和1。

**主要解决的问题:**

1. 尽可能屏蔽物理设备、传输媒体和通讯手段的不同,使上面的数据链路层感觉不到这些差异的存在,而专注于完成本层的协议与服务。

2. 考虑的是怎么样才能在连接各种计算机的传输媒体上传输数据比特流。

| 数据形式 | 数据单位 | 典型代表 |
| - | - | - |
| 二进制数据 | 比特(bit) | V.35、RJ-45(8P8C网线插头) |

### 数据链路层
>根据以太网的协议将一组电信号组成一个数据包，称作帧，通过使用包含纠错和控制信息的方式实现在不可靠的物理线路上进行数据的可靠传递

* 帧的组成:
1. 标头 `head`： 标明数据发送者、接收者、数据类型等。
2. 数据的 `data`

* 传播方式：
广播，发送者将数据表，发送给局域网内的所有`PC`，让每个`PC`根据`MAC`地址自动匹配。

* 常用协议解释：
1. `SLIP`(串行线路`IP`)。
2. `PPP`(点到点协议)。

### MAC地址

>`MAC`（`Media Access Control`，介质访问控制）地址专注于数据链路层，将一个数据帧从一个节点传送到相同链路的另一个节点，所以也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。

`MAC`地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，都有相同的MAC地址，它由厂商写在网卡的`BIOS`里。

`MAC`地址长度为6字节（`48比特`）长度，分为前24位和后24位：前24位是由生产网卡的厂商向`IEEE`申请的厂商地址，后24位由厂商自行分配，这样的分配使得世界上任意一个拥有48位`MAC`地址的网卡都有唯一的标识。

### 网络层

>在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将网络地址翻译成对应的物理地址，将数据设法从源端经过若干个中间节点传送到目的端，从而向运输层提供最基本的端到端的数据传送服务。

**常用协议解释:**
* `IP`(`Internet Protocal`)网络协议
* `ARP`(`Address Resolution Protocal`)地址解析协议
* `ICMP`(`Internet Control Message Protocal`)因特网控制消息协议
* `HDLC`(`High Data Link Control`)高级数据链路控制。

### 传输层

>通过流量控制及调整发送速率等方式为上层提供端到端的透明的、可靠的数据传输服务。

**常用协议解释:**
* `TCP`(Transition Control Protocal)传输控制协议
* `UDP`(User Data Protocal)用户数据协议

### 会话层

>不参与具体的传输，提供了包括访问验证和会话管理在内的建立和维护应用之间通信的机制。
 
### 表示层

>根据不同网络类型提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。

###应用层

>为操作系统或网络应用程序提供访问网络服务的接口。

**常用协议解释:**
* `HTTP`(`HyperText Transfer Protocal`)超文本传输协议
* `FTP`(`File Transfer Protocal`)文件传输协议
* `SMTP`(`Simple Mall Transfer Protocal`)简单邮件传输协议
* `POP3`(`Post Office Protocal`)邮局协议
* `DNS`(`Domain Name System)`域名系统
* `TCP/IP` 协议族

## TCP/IP 协议族
***

>`TCP/IP` 协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：`TCP`，`IP`，`UDP`，`ARP等`，这些被称为子协议。在这些协议中，最重要、最著名的就是 `TCP` 和 `IP`。因此我们习惯将整个协议族称为 `TCP/IP`。

* **`IP` 协议:**

1. `IP` 协议使互联网成为一个允许连接不同类型的计算机和不同操作系统的网络。

2. `IP` 地址是 `IP` 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，相当于这台机器的暂用名，别的机器可以通过这个名字找到它，进而能互相建立起连接进行通信和交流。

* **TCP 协议:**

```markdown
1. `TCP` 协议是面向连接的全双工协议，因此不管是客户端还是服务端都能在 `TCP` 连接通道下向对端接收和发送数据。

2. `TCP` 相比于 `UDP` 的优势在于它的传输稳定性，在数据传输之前必须经过三次握手建立连接；在数据传输过程中必须保证数据有序完整地传到对端。

3. `TCP` 相比于 `UDP` 的劣势在于它的复杂度，连接建立、断开都是比较大的性能开销，而且数据传输过程中一旦卡住，则必须等前面的数据发送完毕以后，后续数据才能继续传输。
```
每台服务器可提供支持的 TCP 连接数量是有限的，所以这也使得 TCP 连接变成了稀缺资源，经不起浪费。

* **UDP 协议:**

1. `UDP` 协议是面向无连接的，不需要在传输数据前先建立连接，想发就发想传就传。

2. `UDP` 做的工作只是报文搬运，不负责有序且不丢失地传递到对端，因此容易出现丢包的情况。

3. `UDP` 不仅支持一对一的传输方式，还支持一对多、多对多、多对一的方式，也就是说 `UPD` 提供了单播、多播、广播的功能。

4. `UDP` 相比于 `TCP` 的优势在于它的轻量、高效和灵活，在一些对于实时性应用要求较高的场景下需要使用到 `UDP`，比如直播、视频会议、`LOL` 等实时对战游戏。

5. `UDP` 相比于 `TCP` 的劣势在于它的不可靠性和不稳定性。

## TCP 连接
***

在客户端发送正式的 `HTTP` 请求之前，需要先创建一个 `TCP` 连接，在创建的 `TCP Connect` 通道下，所有的 `HTTP` 请求和响应才能正常的发送和接受。

**在不同的 `HTTP` 协议版本里，这个 `TCP` 连接通道的创建和持续机制也有所不同。**

* 在 `HTTP1.0` 中，每一次 `HTTP` 请求都会创建一个 `TCP` 连接，在请求发送完成，服务器响应以后，这个 `TCP` 连接就自动断开了。

* 在 `HTTP1.1 `中，可以通过手动设置 `Connection： keep-alive` 请求头来建立 `TCP` 的持久连接，多个 `HTTP` 请求可以共用一个 `TCP` 连接。但是 `TCP` 连接存在线头阻塞，即若干个请求排队等待发送，一旦有某请求超时等，后续请求只能被阻塞。

* 在 `HTTP2.0` 中，采用了信道复用，使 `TCP` 连接支持并发请求，即多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行吗，这样一来，大部分请求可以使用一个 `TCP` 连接，而不用创建新的 `TCP` 连接通道，既节省了三次握手的开销，又节约了服务端维护 `TCP` 端口的成本。



