## `HTTP` 定义
***

>`HTTP`(`HyperText Transfer Protocal`)超文本传输协议，它通常运行在 `TCP` 之上，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，`HTTP` 协议规定了超文本传输所要遵守的规则。

通过 `HTTP` 或者 `HTTPS` 协议请求的资源由统一资源标识符URL(Uniform Resource Identifiers)来标识。

## `HTTP` 特点
***

`http` 主要有以下几个特点:

* 仅支持(客户端/服务端)模式。意味着该请求只能通过客户端发起,服务端响应。

* 简单快速、灵活。

* `HTTP` 协议是无状态的。这意味着客户端和服务端之间无法知晓当前对方的状态信息，`HTTP` 请求本身是不带有任何状态存储的。但实际情况下，客户端和服务端必然需要状态的认证和交互，所以就引入了 `Cookie`、`Session`， 用于存储当前浏览器的一些状态信息，每次通过独立的 `HTTP` 请求进行收发，从而解决这个问题。

* `HTTP` 请求互相独立。`HTTP` 互相之间都是一个独立的个体请求，在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应 `HTML` 页面，然后浏览器收到响应之后发现页面还引用了其他的资源，例如，`CSS`，`JS` 文件，图片等等，还会自动发送 `HTTP` 请求获取这些需要的资源。

* `HTTP` 协议基于 `TCP` 协议。`HTTP` 协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节，底层是基于 `TCP` 实现的。现在使用的版本当中是默认持久连接的，也就是多次 `HTTP` 请求使用一个 `TCP 连接`。

:::warning WARNING

注意：`HTTP` 请求和 `TCP` 连接是不一样的，`HTTP` 是在 `TCP` 连接建立的基础上而发起的传输请求，在同一个 `TCP` 连接通道下，可以发送多个 `HTTP` 请求，举个例子的话就是高速公路和车子的关系。
:::

## `HTTP` 请求响应模型
***

`HTTP` 由请求和响应构成，是一个标准的客户端服务器模型(`B/S`)。

`HTTP` 协议永远是客户端发起，然后服务器返回响应。

![请求响应模型](/images/base-js45.png)

:::tip TIP

`HTTP` 是一个无状态的协议。

无状态是指客户机（`Web浏览器`）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(`response`)，连接就被关闭了，在服务器端不保留连接的有关信息.

`HTTP` 遵循请求(`Request`)/应答(`Response`)模型。客户机（`浏览器`）向服务器发送请求，服务器处理请求并返回适当的应答。所有 `HTTP` 连接都被构造成一套请求和应答。
:::

## `OSI`七层网络模型
***

![七层网络模型](/images/base-js46.png)

### 物理层

>通过光缆、电缆、无线电波等方式将设备连接起来组网，以二进制的数据形式在物理媒体上传输比特流0和1。

**主要解决的问题:**

1. 尽可能屏蔽物理设备、传输媒体和通讯手段的不同,使上面的数据链路层感觉不到这些差异的存在,而专注于完成本层的协议与服务。

2. 考虑的是怎么样才能在连接各种计算机的传输媒体上传输数据比特流。

| 数据形式 | 数据单位 | 典型代表 |
| - | - | - |
| 二进制数据 | 比特(bit) | V.35、RJ-45(8P8C网线插头) |

### 数据链路层
>根据以太网的协议将一组电信号组成一个数据包，称作帧，通过使用包含纠错和控制信息的方式实现在不可靠的物理线路上进行数据的可靠传递

* 帧的组成:
1. 标头 `head`： 标明数据发送者、接收者、数据类型等。
2. 数据的 `data`

* 传播方式：
广播，发送者将数据表，发送给局域网内的所有`PC`，让每个`PC`根据`MAC`地址自动匹配。

* 常用协议解释：
1. `SLIP`(串行线路`IP`)。
2. `PPP`(点到点协议)。

### MAC地址

>`MAC`（`Media Access Control`，介质访问控制）地址专注于数据链路层，将一个数据帧从一个节点传送到相同链路的另一个节点，所以也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。

`MAC`地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，都有相同的MAC地址，它由厂商写在网卡的`BIOS`里。

`MAC`地址长度为6字节（`48比特`）长度，分为前24位和后24位：前24位是由生产网卡的厂商向`IEEE`申请的厂商地址，后24位由厂商自行分配，这样的分配使得世界上任意一个拥有48位`MAC`地址的网卡都有唯一的标识。

### 网络层

>在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将网络地址翻译成对应的物理地址，将数据设法从源端经过若干个中间节点传送到目的端，从而向运输层提供最基本的端到端的数据传送服务。

**常用协议解释:**
* `IP`(`Internet Protocal`)网络协议
* `ARP`(`Address Resolution Protocal`)地址解析协议
* `ICMP`(`Internet Control Message Protocal`)因特网控制消息协议
* `HDLC`(`High Data Link Control`)高级数据链路控制。

### 传输层

>通过流量控制及调整发送速率等方式为上层提供端到端的透明的、可靠的数据传输服务。

**常用协议解释:**
* `TCP`(Transition Control Protocal)传输控制协议
* `UDP`(User Data Protocal)用户数据协议

### 会话层

>不参与具体的传输，提供了包括访问验证和会话管理在内的建立和维护应用之间通信的机制。
 
### 表示层

>根据不同网络类型提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。

###应用层

>为操作系统或网络应用程序提供访问网络服务的接口。

**常用协议解释:**
* `HTTP`(`HyperText Transfer Protocal`)超文本传输协议
* `FTP`(`File Transfer Protocal`)文件传输协议
* `SMTP`(`Simple Mall Transfer Protocal`)简单邮件传输协议
* `POP3`(`Post Office Protocal`)邮局协议
* `DNS`(`Domain Name System)`域名系统
* `TCP/IP` 协议族

## TCP/IP 协议族
***

>`TCP/IP` 协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：`TCP`，`IP`，`UDP`，`ARP等`，这些被称为子协议。在这些协议中，最重要、最著名的就是 `TCP` 和 `IP`。因此我们习惯将整个协议族称为 `TCP/IP`。

* **`IP` 协议:**

1. `IP` 协议使互联网成为一个允许连接不同类型的计算机和不同操作系统的网络。

2. `IP` 地址是 `IP` 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，相当于这台机器的暂用名，别的机器可以通过这个名字找到它，进而能互相建立起连接进行通信和交流。

* **TCP 协议:**

```markdown
1. `TCP` 协议是面向连接的全双工协议，因此不管是客户端还是服务端都能在 `TCP` 连接通道下向对端接收和发送数据。

2. `TCP` 相比于 `UDP` 的优势在于它的传输稳定性，在数据传输之前必须经过三次握手建立连接；在数据传输过程中必须保证数据有序完整地传到对端。

3. `TCP` 相比于 `UDP` 的劣势在于它的复杂度，连接建立、断开都是比较大的性能开销，而且数据传输过程中一旦卡住，则必须等前面的数据发送完毕以后，后续数据才能继续传输。
```
每台服务器可提供支持的 TCP 连接数量是有限的，所以这也使得 TCP 连接变成了稀缺资源，经不起浪费。

* **UDP 协议:**

1. `UDP` 协议是面向无连接的，不需要在传输数据前先建立连接，想发就发想传就传。

2. `UDP` 做的工作只是报文搬运，不负责有序且不丢失地传递到对端，因此容易出现丢包的情况。

3. `UDP` 不仅支持一对一的传输方式，还支持一对多、多对多、多对一的方式，也就是说 `UPD` 提供了单播、多播、广播的功能。

4. `UDP` 相比于 `TCP` 的优势在于它的轻量、高效和灵活，在一些对于实时性应用要求较高的场景下需要使用到 `UDP`，比如直播、视频会议、`LOL` 等实时对战游戏。

5. `UDP` 相比于 `TCP` 的劣势在于它的不可靠性和不稳定性。

## TCP 连接
***

在客户端发送正式的 `HTTP` 请求之前，需要先创建一个 `TCP` 连接，在创建的 `TCP Connect` 通道下，所有的 `HTTP` 请求和响应才能正常的发送和接受。

**在不同的 `HTTP` 协议版本里，这个 `TCP` 连接通道的创建和持续机制也有所不同。**

* 在 `HTTP1.0` 中，每一次 `HTTP` 请求都会创建一个 `TCP` 连接，在请求发送完成，服务器响应以后，这个 `TCP` 连接就自动断开了。

* 在 `HTTP1.1 `中，可以通过手动设置 `Connection： keep-alive` 请求头来建立 `TCP` 的持久连接，多个 `HTTP` 请求可以共用一个 `TCP` 连接。但是 `TCP` 连接存在线头阻塞，即若干个请求排队等待发送，一旦有某请求超时等，后续请求只能被阻塞。

* 在 `HTTP2.0` 中，采用了信道复用，使 `TCP` 连接支持并发请求，即多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行吗，这样一来，大部分请求可以使用一个 `TCP` 连接，而不用创建新的 `TCP` 连接通道，既节省了三次握手的开销，又节约了服务端维护 `TCP` 端口的成本。

::: tip TIP

如何查看 `TCP` 连接复用:
图上可以看到有不同的 `Connection ID`，这就代表着本次请求实际上是开启了一个新的 `TCP` 连接，如果请求的 `Connection ID` 都是相同的，代表着多个 `HTTP` 请求复用了同一个 `TCP` 连接。
:::

:::warning WARNING

`Chrome` 浏览器所能够支持的最大并发 `TCP` 连接数是 6 个知乎上的视频链接，并且在 `HTTP 2.0` 以下的 `HTTP` 版本中，请求是阻塞的。也就是说，一旦六个连接开满，前面的请求未完成，那么后续请求就会被阻塞，直到前面的请求返回，后续才能继续发送。
:::

## HTTP 工作过程

一次 `HTTP` 操作称为一个事务，其工作整个过程如下：

1. **地址解析**
如用客户端浏览器请求这个页面：`localhost.com:8080/index.htm`

从中分解出`协议名`、`主机名`、`端口`、`对象路径`等部分，对于我们的这个地址，解析得到的结果如下：

```text
协议名：http
主机名：localhost.com
端口：8080
对象路径：/index.htm
```
在这一步，需要域名系统 `DNS` 解析域名 `localhost.com` ,得到主机的 `IP` 地址。

2. **封装 HTTP 请求数据包**
把以上部分结合本机自己的信息，封装成一个 `HTTP` 请求数据包

3. **封装成 `TCP` 包，建立 `TCP` 连接（`TCP` 的三次握手）**

在 `HTTP` 工作开始之前，客户机（`Web 浏览器`）首先要通过网络与服务器建立连接，该连接是通过 `TCP` 来完成的，该协议与 `IP` 协议共同构建 `Internet`，即著名的`TCP/IP`协议族，因此`Internet`又被称作是`TCP/IP`网络。

`HTTP` 是比 `TCP` 更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行高层协议的连接，因此，首先要建立 `TCP` 连接，一般 `TCP` 连接的端口号是 `80`。这里是`8080`端口。

**补充**:三次握手

![三次握手](/images/base-js48.png)

:::tip TIP

提示：关于 `ACK`、`FIN`、`SYN` 状态码的含义

`ACK` 用于确认，表示通知对方，我已经收到你发来的信息了。

`FIN` 用于结束，表示告知对方，我这边已经结束，数据全部发送完毕，没有后续输出，请求终止连接。

`SYN` 用于同步和建立连接，表示告知对方，我这边请求同步建立连接。
:::

* 第一次握手：由客户端向服务端发送连接请求 SYN 报文，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 SYN-SENT 状态。

* 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个包含了 `ACK` 和 `SYN` 报文信息的应答，该应答中也会包含自身的数据通讯初始序号（在断开连接的“四次挥手”时，`ACK` 和 `SYN` 这两个报文是作为两次应答，独立开来发送的，因此会有四次挥手），服务端发送完成后便进入 `SYN-RECEIVED` 状态。

* 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 `ESTABLISHED` 状态，服务端收到这个应答后也进入 `ESTABLISHED` 状态，此时连接建立成功。

:::tip TIP

**面试时可能会问的一个问题就是，明明两次握手就能确定的连接，为什么需要三次握手？**

因为由于很多不可控制的因素，例如网络原因，可能会造成第一次请求隔了很久才到达服务端，这个时候客户端已经等待响应等了很久，之前发起的请求已超时，已经被客户端废弃掉不再继续守着监听了。

然而服务端过了很久，收到了废弃的延迟请求，发起回应的同时又开启了一个新的 TCP 连接端口，在那里呆等客户端。

而服务端能维护的 `TCP` 连接是有限的，这种闲置的无用链接会造成服务端的资源浪费。

因此在服务端发送了 `SYN` 和 `ACK` 响应后，需要收到客户端接的再次确认，双方连接才能正式建立起来。`三次握手就是为了规避这种由于网络延迟而导致服务器额外开销的问题`。
:::

**补充：四次挥手**


![四次挥手](/images/base-js47.png)

和建立 `TCP` 连接类似，断开 `TCP` 连接也同样需要客户端于服务端的双向交流，因为整个断开动作需要双端共发送 4 个数据包才能完成，所以简称为“四次挥手”。

* 第一次挥手：客户端认为自己这边的数据已经全部发送完毕了，于是发送一个 FIN 用来关闭客户端到服务端的数据传输，发送完成以后，客户端进入 FIN_WAIT_1 状态。

* 第二次挥手：服务端收到客户端发送回来的 FIN 以后，会告诉应用层要释放 TCP 链接，并且发送一个 ACK 给客户端，表明已经收到客户端的释放请求了，不会再接受客户端发来的数据，自此，服务端进入 CLOSE_WAIT 的状态。

* 第三次挥手：服务端如果此时还有未发送完的数据可以继续发送，发送完毕后，服务端也会发送一个释放连接的 FIN 请求用来关闭服务端到客户端的数据传送，然后服务端进入 LAST_ACK 状态。

* 第四次挥手：客户端接收到服务端的 FIN 请求后，发送最后一个 ACK 给服务端，接着进入 TIME_WAIT_2 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，客户端就进入 CLOSED 状态.服务端在收到应答消息后，也会进入 CLOSED 状态，至此完成四次挥手的过程，双方正式断开连接。

:::tip TIP

可能有些面试中会问，为什么建立连接有三次握手，而断开连接却有四次？

这是因为在建立连接过程中，服务端在收到客户但建立连接请求的 SYN 报文后，会把 ACK 和 SYN 放在一个报文里发送给客户端。 而关闭连接时，服务端收到客户端的 FIN 报文，只是表示客户端不再发送数据了，但是还能接收数据，而且这会儿服务端可能还有数据没有发送完，不能马上发送 FIN 报文，只能先发送 ACK 报文，先响应客户端，在确认自己这边所有数据发送完毕以后，才会发送 FIN。 所以，在断开连接时，服务器的 ACK 和 FIN 一般都会单独发送，这就导致了断开连接比请求连接多了一次发送操作。
:::

4. **客户机发送请求命令**

一旦端对端成功建立起了 `TCP` 连接，下一步就要开始发送正式的 HTTP 请求了，请求方式的格式为：`统一资源标识符（URL）`、`协议版本号`，后边是`MIME`信息包括`请求修饰符`、`客户机信息`和`可见内容`。

:::tip TIP

流淌在 `TCP Connect` 通道里的 `HTTP` 只负责传输数据包，并没有连接的概念，因此 `HTTP` 也被叫做无状态协议。
:::
       
5. **服务器响应**

服务器接到请求后，给予相应的响应信息，其格式为一个`状态行`，包括信息的`协议版本号`、`一个成功或错误的代码`，后边是`MIME`信息包括服务器信息、实体信息和可能的内容。

实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

6. **服务器关闭 `TCP` 连接**
       
一般情况下，一旦`Web`服务器向浏览器发送了请求数据，它就要关闭`TCP`连接，然后如果浏览器或者服务器在其头信息加入了这行代码:

```textmate
Connection: keep - alive;
```

`TCP`连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

### `HTTP` 工作过程用到的概念

**报文格式**

`HTTP1.0` 的报文有两种类型：请求和响应。其报文格式分别为：

:::tip TIP

请求报文格式

* 请求方法 URL HTTP/版本号
* 请求首部字段(可选)
* 空行
* body(只对 Post 请求有效)
:::
       
```textmate
GET http://m.baidu.com/ HTTP/1.1
Host m.baidu.com
Connection Keep-Alive
...// 其他header
key=iOS
```

:::tip TIP

响应报文格式

* HTTP/版本号 返回码 返回码描述
* 应答首部字段(可选)
* 空行
* body
:::

```textmate
HTTP/1.1 200 OK
Content-Type text/html;charset=UTF-8
...// 其他header

<html>...
```

### `URL` 的结构

使用 `HTTP` 协议访问资源是通过`URL（Uniform Resource Locator）`统一资源定位符来实现的。`URL` 的格式如下：

```textmate
scheme://host:port/path?query

scheme: 表示协议，如http, https, ftp等；
host: 表示所访问资源所在的主机名：如：www.baidu.com;
port: 表示端口号，默认为80；
path: 表示所访问的资源在目标主机上的储存路径；
query: 表示查询条件；

例如： http://www.baidu.com/search?words=Baidu
```

### `HTTP` 的请求方法

* `GET`: 获取 `URL` 指定的资源。
* `POST`：一般用于传输实体信息。
* `PUT`：一般用于上传文件。
* `DELETE`：删除文件。
* `HEAD`：获取报文首部，与 `GET` 相比，不返回报文主体部分。
* `OPTIONS`：用于预检请求中，询问请求 `URI` 资源支持的方法。
* `TRACE`：追踪请求的路径；。
* `CONNECT`：要求在与代理服务器通信时建立隧道，使用隧道进行 `TCP` 通信。主要使用 `SSL` 和 `TLS` 将数据加密后通过网络隧道进行传输。

### 报文字段

`HTTP` 首部字段由字段名和字段值组成，中间以":"分隔，如`Content-Type: text/html`.其中，同一个字段名可对应多个字段值。

`HTTP` 的报文字段分为 5 种：

1. 请求报文字段
2. 应答报文字段
3. 实体首部字段
4. 通用报文字段
5. 其他报文字段

**请求报文字段**

`HTTP` 请求中支持的报文字段。

* `Accept`：客户端能够处理的媒体类型。如`text/html`, 表示客户端让服务器返回`html`类型的数据，如果没有，返回`text`类型的也可以。媒体类型的格式一般为：`type/subType`, 表示优先请求`subType`类型的数据，如果没有，返回 `type` 类型数据也可以。

**常见的媒体类型：**

1. 文本文件：`text/html`, `text/plain`, `text/css`, `application/xml`
2. 图片文件：`image/jpeg`, `image/gif`, `image/png`
3. 视频文件：`video/mpeg`
4. 应用程序使用的二进制文件：`application/octet-stream`, `application/zip`

:::tip TIP

`Accept`字段可设置多个字段值，这样服务器依次进行匹配，并返回最先匹配到的媒体类型，当然，也可通过 q 参数来设置 媒体类型的权重，权重越高，优先级越高。q 的取值为[0, 1], 可取小数点后 3 位，默认为 1.0。例如： `Accept: text/html`,` application/xml; q=0.9, */*`
:::

* `Accept-Charset`: 表示客户端支持的字符集。例如：`Accept-Charset: GB2312, ISO-8859-1`

* `Accept-Encoding`： 表示客户端支持的内容编码格式。如：`Accept-Encoding：gzip`

**常用的内容编码：**

1. `gzip`: 由文件压缩程序`gzip`生成的编码格式；
2. `compress`: 由`Unix`文件压缩程序`compress`生成的编码格式；
3. `deflate`: 组合使用`zlib`和`deflate`压缩算法生成的编码格式；
4. `identity`：默认的编码格式，不执行压缩。

