**什么是前端单元测试？**
1. 为检测特定的目标是否符合标准而采用专用的工具或者方法进行验证，并最终得出特定的结果。
2. 对于前端开发过程来说，这里的特定目标就是指我们写的代码，通过写的测试用例检查的结果展示测试是否通过或者给出测试报告，这样才能方便问题的排查和后期的修正
3. 对于给定的输入，单元测试检查结果。通过及早发现问题并避免 bug 回归，它可以帮助我们确保代码的各个部分按预期工作。

**为什么需要单元测试？**

前端的单元测试在很多人看来都是一个可有可无的东西，理由一般有下面几条：

* 写单测比较费时，有这个时间不如多做几个需求
* 测试在验收的时候对页面的功能都会操作一遍，写单测相当于做无用功
* 后端提供给前端的接口需要保证质量，因此需要做单测，但前端很少需要提供接口给其他人

其实，我大体上是同意以上观点的。在大部分的情况下，如果公司的业务不复杂，是完全没必要做单测的。但如果涉及到以下几个方面，就要考虑是否有必要引入单测了：

* 业务比较复杂，前端参与的人员超过3人
* 公司非常注重代码质量，想尽一切办法杜绝线上出bug
* 你是跨项目组件的提供方 你在做一个开源项目

单测的好处：减少bug，提升代码可读性可维护性，为系统重构做铺垫。

**单元测试覆盖率**

**含义**：软件测试中的一种度量指标，指在所有功能代码中，完成了单元测试的代码所占的比例。具体分为行级、分支级、方法级等不同级别。它可以从一定程度上衡量我们对代码测试的充分性。原则上我们追求的单元测试覆盖率目标是100%，但业务场景多的情况几乎是不可能。
平台类项目，核心复杂功能尽量覆盖率做到最高，业务类的酌情处理。

**目标覆盖率**：
行覆盖率（line coverage）：表示是否每一行都执行 80%
函数覆盖率（function coverage）：表示是否每个函数都调用 100%
分支覆盖率（branch coverage）：表示是否每个if代码块都执行 80%
语句覆盖率（statement coverage）：表示是否每个语句都执行 80%

# 前端单测规范

在单测工作开展前，需要先约定好单测相应的一系列规范：

1. 测试文件统一在 src/tests 目录中维护 或者 与组件同级目录 如 button.test.tsx 跟button.tsx 文件同级。
2. 测试文件命名与React组件命名保持一致，后面以.test.tsx结尾
3. 测试用例使用`it("功能描述",()=>{})`函数描述用例单元
针对最小功能单元的测试用例主要集中在该函数内 尽量一个测试用例只做一件事情（每个测试用例一个it函数代表）。字符串代表测试用例名称：常用命名模式“被测对象在什么情况下是什么行为”
4. 一组功能集合测试使用`describe("功能集合描述",()=>{})`函数描述功能集合
一个测试文件只能描述一个功能集合，这个功能集合可以是一个React组件，也可以是一个公共模块，公共函数，公共配置。尽量每次编写测试用例都用`describe`包裹进行分块。

* UI测试套件统一使用enzyme
使用enzyme可以借助jquery like的选择器方便的对DOM渲染结果做校验
* React组件测试用例必须包含：
* Snapshot快照比对
* Props是否正确传入
* 组件分支渲染
* 事件调用和参数传递
* 函数调用，state状态值的改变
* 页面跳转回应

针对这一点我们可以根据这些维度来对我们的代码进行测试：

* 某个子组件，标签，CSS class类 在组件中的个数，长度
* 某个标签下文本内容是否一致
* 标签类型
* 组件中函数调用是否符合预期，模拟调用该函数给定参数能否与预期结果一致
* 针对公共js库模块进行快照测试，确保当次更改是否需要
* 在执行某些操作后state的状态值是否发生改变，某个标签元素是否渲染

# 单测框架技术选型
目前比较流行的React单测组合是Jest+Enzyme

**Jest**
Jest是Facebook开发的一个测试框架，它集成了测试执行器、断言库、spy、mock、snapshot和测试覆盖率报告等功能。React项目本身也是使用Jest进行单测的，因此它们俩的契合度相当高。
它具有特点:

* 开箱即用，配置少，API简单，上手成本极低在沙箱中运行，更加安全
* 支持断言和仿真
* 自动生成测试覆盖率报告
* 通过生成 `Snapshot` 进行UI 测试单测执行效率

**Enzyme**
Enzyme是由airbnb开发的React单测工具。它针对类 react 组件提供了很多关于 UI 渲染，元素查找，事件触发等相关的 API 和匹配器，可以帮助我们更加高效的完成单测编写。它扩展了React的TestUtils并通过支持类似jQuery的find语法可以很方便的对render出来的结果做各种断言。

* 方便操作 `Dom` 且操作风格模拟了 `jQuery` 的 `APi`，比较直观，学习使用都比较简单
* 便利的工具函数库封装，可以处理浅渲染，静态渲染标记以及`DOM`渲染。

## 测试工具 jest介绍

主要介绍jest 基础的js 到[vue的组件测试](https://cn.vuejs.org/v2/guide/testing.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)

 [jest官网](https://jestjs.io/zh-Hans/docs/getting-started)
 
**安装**
```text
npm install --save-dev jest 
```
或者
```text
yarn add --dev jest
```
## 基础dome

举个例子，我们先写一个两数相加的函数。 首先，创建 `sum.js` 文件︰
```js
function sum(a, b) {
  return a + b;
}
module.exports = sum;
```
然后，创建名为 `sum.test.js` 的文件。 此文件中将包含我们的实际测试︰
```js
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```
随后，将下列配置内容添加到您的 `package.json`：
```json
{
  "scripts": {
    "test": "jest"
  }
}
```
最后，运行 yarn test 或 npm run test ，Jest将打印下面这个消息：
```text
PASS  ./sum.test.js
✓ adds 1 + 2 to equal 3 (5ms)
```

## 匹配器的基本使用
```test.js
test('two plus two is four', () => {
  expect(2 + 2).toBe(4);
});
```
在上面的代码中，`expect (2 + 2)` 返回了一个"预期"的对象。 你通常不会对这些期望对象调用过多的匹配器。 在此代码中，`.toBe(4)` 是匹配器。 当 `Jest` 运行时，它会跟踪所有失败的匹配器，以便它可以为你打印出很好的错误消息。

`toBe`使用 `Object.is`来进行精准匹配的测试。 如果您想要检查对象的值，请使用 `toEqual` 代替：
```test.js
test('对象赋值', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
```
`toEqual` 递归检查对象或数组的每个字段。

您还可以测试相反的匹配︰
```test.js
test('adding positive numbers is not zero', () => {
  for (let a = 1; a < 10; a++) {
    for (let b = 1; b < 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});
```

**真值**

代码中的 `undefined`, `null`, and `false` 有不同含义，若你在测试时不想区分他们，可以用真值判断。 Jest提供helpers供你使用。

* `toBeNull` 只匹配 `null`
* `toBeUndefined` 只匹配 `undefined`
* `toBeDefined` 与 `toBeUndefined` 相反
* `toBeTruthy` 匹配任何 `if` 语句为真
* `toBeFalsy` 匹配任何 `if` 语句为假
例如：

```text
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
```

**数字**

```text
test('two plus two', () => {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});
```
对于比较浮点数相等，使用 `toBeCloseTo` 而不是 `toEqual`，因为你不希望测试取决于一个小小的舍入误差。
```text
test('两个浮点数字相加', () => {
  const value = 0.1 + 0.2;
  //expect(value).toBe(0.3);           这句会报错，因为浮点数有舍入误差
  expect(value).toBeCloseTo(0.3); // 这句可以运行
});
});
```

**字符串**
您可以检查对具有 `toMatch` 正则表达式的字符串︰
```text
test('there is no I in team', () => {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
  expect('Christoph').toMatch(/stop/);
});
```

**数组和可迭代对象**
你可以通过 `toContain` 来检查一个数组或可迭代对象是否包含某个特定项：
```text
const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'milk',
];

test('shoppingList数组中包含milk', () => {
  expect(shoppingList).toContain('milk');
  expect(new Set(shoppingList)).toContain('milk');
});
```
