**什么是前端单元测试？**
1. 为检测特定的目标是否符合标准而采用专用的工具或者方法进行验证，并最终得出特定的结果。
2. 对于前端开发过程来说，这里的特定目标就是指我们写的代码，通过写的测试用例检查的结果展示测试是否通过或者给出测试报告，这样才能方便问题的排查和后期的修正
3. 对于给定的输入，单元测试检查结果。通过及早发现问题并避免 bug 回归，它可以帮助我们确保代码的各个部分按预期工作。

**为什么需要单元测试？**

前端的单元测试在很多人看来都是一个可有可无的东西，理由一般有下面几条：

* 写单测比较费时，有这个时间不如多做几个需求
* 测试在验收的时候对页面的功能都会操作一遍，写单测相当于做无用功
* 后端提供给前端的接口需要保证质量，因此需要做单测，但前端很少需要提供接口给其他人

其实，我大体上是同意以上观点的。在大部分的情况下，如果公司的业务不复杂，是完全没必要做单测的。但如果涉及到以下几个方面，就要考虑是否有必要引入单测了：

* 业务比较复杂，前端参与的人员超过3人
* 公司非常注重代码质量，想尽一切办法杜绝线上出bug
* 你是跨项目组件的提供方 你在做一个开源项目

单测的好处：减少bug，提升代码可读性可维护性，为系统重构做铺垫。

**单元测试覆盖率**

**含义**：软件测试中的一种度量指标，指在所有功能代码中，完成了单元测试的代码所占的比例。具体分为行级、分支级、方法级等不同级别。它可以从一定程度上衡量我们对代码测试的充分性。原则上我们追求的单元测试覆盖率目标是100%，但业务场景多的情况几乎是不可能。
平台类项目，核心复杂功能尽量覆盖率做到最高，业务类的酌情处理。

**目标覆盖率**：
行覆盖率（line coverage）：表示是否每一行都执行 80%
函数覆盖率（function coverage）：表示是否每个函数都调用 100%
分支覆盖率（branch coverage）：表示是否每个if代码块都执行 80%
语句覆盖率（statement coverage）：表示是否每个语句都执行 80%

# 前端单测规范

在单测工作开展前，需要先约定好单测相应的一系列规范：

1. 测试文件统一在 src/tests 目录中维护 或者 与组件同级目录 如 button.test.tsx 跟button.tsx 文件同级。
2. 测试文件命名与React组件命名保持一致，后面以.test.tsx结尾
3. 测试用例使用`it("功能描述",()=>{})`函数描述用例单元
针对最小功能单元的测试用例主要集中在该函数内 尽量一个测试用例只做一件事情（每个测试用例一个it函数代表）。字符串代表测试用例名称：常用命名模式“被测对象在什么情况下是什么行为”
4. 一组功能集合测试使用`describe("功能集合描述",()=>{})`函数描述功能集合
一个测试文件只能描述一个功能集合，这个功能集合可以是一个React组件，也可以是一个公共模块，公共函数，公共配置。尽量每次编写测试用例都用`describe`包裹进行分块。

* UI测试套件统一使用enzyme
使用enzyme可以借助jquery like的选择器方便的对DOM渲染结果做校验
* React组件测试用例必须包含：
* Snapshot快照比对
* Props是否正确传入
* 组件分支渲染
* 事件调用和参数传递
* 函数调用，state状态值的改变
* 页面跳转回应

针对这一点我们可以根据这些维度来对我们的代码进行测试：

* 某个子组件，标签，CSS class类 在组件中的个数，长度
* 某个标签下文本内容是否一致
* 标签类型
* 组件中函数调用是否符合预期，模拟调用该函数给定参数能否与预期结果一致
* 针对公共js库模块进行快照测试，确保当次更改是否需要
* 在执行某些操作后state的状态值是否发生改变，某个标签元素是否渲染

# 单测框架技术选型
目前比较流行的React单测组合是Jest+Enzyme

**Jest**
Jest是Facebook开发的一个测试框架，它集成了测试执行器、断言库、spy、mock、snapshot和测试覆盖率报告等功能。React项目本身也是使用Jest进行单测的，因此它们俩的契合度相当高。
它具有特点:

* 开箱即用，配置少，API简单，上手成本极低在沙箱中运行，更加安全
* 支持断言和仿真
* 自动生成测试覆盖率报告
* 通过生成 `Snapshot` 进行UI 测试单测执行效率

**Enzyme**
Enzyme是由airbnb开发的React单测工具。它针对类 react 组件提供了很多关于 UI 渲染，元素查找，事件触发等相关的 API 和匹配器，可以帮助我们更加高效的完成单测编写。它扩展了React的TestUtils并通过支持类似jQuery的find语法可以很方便的对render出来的结果做各种断言。

* 方便操作 `Dom` 且操作风格模拟了 `jQuery` 的 `APi`，比较直观，学习使用都比较简单
* 便利的工具函数库封装，可以处理浅渲染，静态渲染标记以及`DOM`渲染。

## 测试工具 jest介绍

主要介绍jest 基础的js 到[vue的组件测试](https://cn.vuejs.org/v2/guide/testing.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)

 [jest官网](https://jestjs.io/zh-Hans/docs/getting-started)
 
**安装**
```text
npm install --save-dev jest 
```
或者
```text
yarn add --dev jest
```

## 基础dome

举个例子，我们先写一个两数相加的函数。 首先，创建 `sum.js` 文件︰
```js
function sum(a, b) {
  return a + b;
}
module.exports = sum;
```
然后，创建名为 `sum.test.js` 的文件。 此文件中将包含我们的实际测试︰
```js
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```
随后，将下列配置内容添加到您的 `package.json`：
```json
{
  "scripts": {
    "test": "jest"
  }
}
```
最后，运行 yarn test 或 npm run test ，Jest将打印下面这个消息：
```text
PASS  ./sum.test.js
✓ adds 1 + 2 to equal 3 (5ms)
```

## 匹配器的基本使用
```test.js
test('two plus two is four', () => {
  expect(2 + 2).toBe(4);
});
```
在上面的代码中，`expect (2 + 2)` 返回了一个"预期"的对象。 你通常不会对这些期望对象调用过多的匹配器。 在此代码中，`.toBe(4)` 是匹配器。 当 `Jest` 运行时，它会跟踪所有失败的匹配器，以便它可以为你打印出很好的错误消息。

`toBe`使用 `Object.is`来进行精准匹配的测试。 如果您想要检查对象的值，请使用 `toEqual` 代替：
```test.js
test('对象赋值', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
```
`toEqual` 递归检查对象或数组的每个字段。

您还可以测试相反的匹配︰
```test.js
test('adding positive numbers is not zero', () => {
  for (let a = 1; a < 10; a++) {
    for (let b = 1; b < 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});
```

**真值**

代码中的 `undefined`, `null`, and `false` 有不同含义，若你在测试时不想区分他们，可以用真值判断。 Jest提供helpers供你使用。

* `toBeNull` 只匹配 `null`
* `toBeUndefined` 只匹配 `undefined`
* `toBeDefined` 与 `toBeUndefined` 相反
* `toBeTruthy` 匹配任何 `if` 语句为真
* `toBeFalsy` 匹配任何 `if` 语句为假
例如：

```text
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
```

**数字**

```text
test('two plus two', () => {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});
```
对于比较浮点数相等，使用 `toBeCloseTo` 而不是 `toEqual`，因为你不希望测试取决于一个小小的舍入误差。
```text
test('两个浮点数字相加', () => {
  const value = 0.1 + 0.2;
  //expect(value).toBe(0.3);           这句会报错，因为浮点数有舍入误差
  expect(value).toBeCloseTo(0.3); // 这句可以运行
});
});
```

**字符串**
您可以检查对具有 `toMatch` 正则表达式的字符串︰
```text
test('there is no I in team', () => {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
  expect('Christoph').toMatch(/stop/);
});
```

**数组和可迭代对象**
你可以通过 `toContain` 来检查一个数组或可迭代对象是否包含某个特定项：
```text
const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'milk',
];

test('shoppingList数组中包含milk', () => {
  expect(shoppingList).toContain('milk');
  expect(new Set(shoppingList)).toContain('milk');
});
```

这些只是浅尝辄止。 匹配器的完整列表，请查阅 [参考文档](https://jestjs.io/zh-Hans/docs/asynchronous)。

## 测试异步代码

在 `JavaScript` 中执行异步代码是很常见的。 当你有以异步方式运行的代码时，`Jest` 需要知道当前它测试的代码是否已完成，然后它可以转移到另一个测试。 `Jest` 有若干方法处理这种情况。
**Promise**

为你的测试返回一个 `Promise`，则`Jest`会等待`Promise`的`resove`状态 `If the promise is rejected, the test will fail.`

`For example, let's say that fetchData returns a promise that is supposed to resolve to the string 'peanut butter'.` 我们可以使用下面的测试代码︰

```text
test('the data is peanut butter', () => {
  return fetchData().then(data => {
    expect(data).toBe('peanut butter');
  });
});
```

**Async/Await**
或者，您可以在测试中使用 `async` 和 `await`。 写异步测试用例时，可以在传递给test的函数前面加上 `async`。 例如，可以用来测试相同的 `fetchData` 方案︰

```text
test('the data is peanut butter', async () => {
  const data = await fetchData();
  expect(data).toBe('peanut butter');
});

test('the fetch fails with an error', async () => {
  expect.assertions(1);
  try {
    await fetchData();
  } catch (e) {
    expect(e).toMatch('error');
  }
});
```
你也可以将 `async` and `await` 和 `.resolves` or `.rejects`一起使用。
```text
test('the data is peanut butter', async () => {
  await expect(fetchData()).resolves.toBe('peanut butter');
});

test('the fetch fails with an error', async () => {
  await expect(fetchData()).rejects.toMatch('error');
});
```
上述示例中，`async` and `await` 实际上是一种基于`Promise`的异步语法糖。

:::warning CAUTION
Be sure to return (or `await`) the promise - if you omit the `return`/`await` statement, your test will complete before the promise returned from `fetchData` resolves or rejects.
:::

如果期望`Promise`被`Reject`，则需要使用 `.catch` 方法。 请确保添加 `expect.assertions` 来验证一定数量的断言被调用。 否则，一个`fulfilled`状态的`Promise`不会让测试用例失败。
```text
test('the fetch fails with an error', () => {
  expect.assertions(1);
  return fetchData().catch(e => expect(e).toMatch('error'));
});
```

**回调**
If you don't use promises, you can use callbacks. For example, let's say that `fetchData`, instead of returning a promise, expects a callback, i.e. fetches some data and calls `callback(null, data)` when it is complete. 你期望返回的数据是一个字符串 `peanut butter`

默认情况下，一旦到达运行上下文底部Jest测试立即结束。 这样意味着这个测试将不能按预期工作。
```text
// 不要这样做！！！
test('the data is peanut butter', () => {
  function callback(error, data) {
    if (error) {
      throw error;
    }
    expect(data).toBe('peanut butter');
  }

  fetchData(callback);
});
```
问题在于一旦 `fetchData` 执行结束，此测试就在调用回调函数前结束了（因为同步代码结束后，才是异步拿到的数据）。

还有另一种形式的 `test` 可以解决这个问题。 使用单个参数调用 `done`，而不是将测试放在一个空参数的函数。 `Jest` 会等 `done` 回调函数被调用执行结束后，再结束测试。
```text
test('the data is peanut butter', done => {
     function callback(error, data) {
       if (error) {
         done(error);
         return;
       }
       try {
         expect(data).toBe('peanut butter');
         done();
       } catch (error) {
         done(error);
       }
     }
   
     fetchData(callback);
   });
```
若 `done()` 函数从未被调用，测试用例会正如你预期的那样执行失败（显示超时错误）。

若 `expect` 执行失败，它会抛出一个错误，后面的 `done()` 不再执行。 若我们想知道测试用例为何失败，我们必须将 `expect` 放入 `try` 中，将 `error` 传递给 `catch` 中的 `done函数`。 否则，最后控制台将显示一个超时错误失败，不能显示我们在 `expect(data)` 中接收的值。

注意： `done()` 不应与Promises混合，因为这会导致您测试中的内存泄漏。

# Vue单元测试

`Vue Test Utils` 是` Vue.js` 官方的单元测试实用工具库。

以 `Vue3`为例

* 安装工具
```text
vue add @vue/cli-plugin-unit-jest
```
 这个命令会帮我们把相关的配置都配好，相关的依赖都装好，还会帮我们生成一个`jest.config.js`文件。

* jest中常用的一些配置项的介绍
```text
module.exports = {
    "moduleFileExtensions": [ //不需要配置
        "js",
        "json",
        // 告诉 Jest 处理 `*.vue` 文件
        "vue"
    ],
    testMatch: [ //test文件所在位置
        '**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)'
    ],
    "transform": {  //不需要配置
        // 用 `vue-jest` 处理 `*.vue` 文件
        ".*\\.(vue)$": "<rootDir>/node_modules/vue-jest",
        // 用 `babel-jest` 处理 js
        "^.+\\.js$": "babel-jest"
    },
    "moduleNameMapper": { //不需要配置
        "^@/(.*)$": "<rootDir>/src/$1"
    },
    "collectCoverage": true,  //是否创建报告
    "collectCoverageFrom": ["**/*.{js,vue}", "!**/node_modules/**"], //创建报告的文件来源
    "coverageReporters": ["html", "text-summary"]   //报告的格式                
    "coveragePathIgnorePatterns":["node_modules"]   //生成报告需要忽略的文件，默认值为     
     "globals":{ //配置全局变量，此处我配置了一个全局变量VUE_APP_DATA，也可以在setup file中配置，如下说的lodash      
        "VUE_APP_DATA": {siteENV:'DEV'}
   } ,
   setupFiles: ['<rootDir>/src/jest-setup.js'] //启动jest需要的文件
};
```

* 在项目目录中创建tests文件，再创建unit文件，在其中文件命名的话，就以 xxx.spec.js命名（这个执行命令的时候，已经给我们创建了）

```text
import { shallowMount } from '@vue/test-utils'
import explame from '@/components/Explame'
 
describe('Explame .vue', () => {
  it('renders props.msg when passed', () => {
    const msg = 'new message'
    const wrapper = shallowMount(Explame , {
      propsData: { msg }
    })
    expect(wrapper.text()).toMatch(msg)
  })
})
```

* 在 `package.json`中添加启动命令，然后通过在控制台执行 `npm run test:unit` ，进行测试

**在package.json中 设置 --coverage 即可 测试覆盖率**
` "test:unit": "vue-cli-service test:unit --coverage"`

* %stmts是语句覆盖率（statement coverage）：是不是每个语句都执行了？
* %Branch分支覆盖率（branch coverage）：是不是每个if代码块都执行了？
* %Funcs函数覆盖率（function coverage）：是不是每个函数都调用了？
* %Lines行覆盖率（line coverage）：是不是每一行都执行了？

**常用api**
--mount: 创建一个包含被挂载和渲染的 Vue 组件的 wrapper,它仅仅挂载当前实例

---shallowMount：和 mount 一样，创建一个包含被挂载和渲染的 Vue 组件的 Wrapper，只挂载一个组件而不渲染其子组件 (即保留它们的存根),这个方法可以保证你关心的组件在渲染时没有同时将其子组件渲染，避免了子组件可能带来的副作用（比如Http请求等）

---shallowMount和mount的区别：在文档中描述为"不同的是被存根的子组件"，大白话就是shallowMount不会加载子组件，不会被子组件的行为属性影响该组件。

 为什么使用shallowMount而不使用mount？

---我认为单元测试的重点在"单元"二字，而不是"测试"，想测试子组件再为子组件写对应的测试代码即可

---Wrapper：常见的有一下几种方法

* Wrapper：Wrapper 是一个包括了一个挂载组件或 vnode，以及测试该组件或 vnode 的方法。
* Wrapper.vm：这是该 Vue 实例。你可以通过 wrapper.vm 访问一个实例所有的方法和属性。
* Wrapper.classes: 返回是否拥有该class的dom或者类名数组。
* Wrapper.find：返回第一个满足条件的dom。
* Wrapper.findAll：返回所有满足条件的dom。
* Wrapper.html：返回html字符串。
* Wrapper.text：返回内容字符串。
* Wrapper.setData：设置该组件的初始data数据。
* Wrapper.setProps：设置该组件的初始props数据。  （这是使用了，但没有效果）
* Wrapper.trigger：用来触发事件。
[更多api](https://v1.test-utils.vuejs.org/zh/api/)
